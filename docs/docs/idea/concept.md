## React理念

> React 是用 JavaScript 构建**快速响应**的大型 Web 应用程序的首选方式。

所以React的关键实现`快速响应`，那么制约`快速响应`的因素是什么呢？  

在日常使用网页时，有两类场景会制约`快速响应`：
+ 遇到需要大量计算的操作时使页面掉帧，造成卡顿
+ 在发送网络请求时，由于数据传输过程中的往返时延，导致的等待  

这两类场景可以概括为：
+ CPU的瓶颈
+ IO的瓶颈

## React解决方式

### CPU的瓶颈
由于`JS`可以操作`DOM`，`GUI`渲染现成与`JS`线程是互斥的，所以**JS脚本的执行**和**浏览器布局**、*绘制**是不能同时执行的。  

且电脑屏幕每次刷新的*16.6ms*内，需要完成：
```
JS脚本执行 --> 样式布局 --> 页面绘制
```
所以，在一帧当中，当`JS`脚本执行时间过长，显然会导致后续的渲染流水线执行时间缩短，甚至没有时间执行，就造成页面掉帧和用户感知的卡顿。  

解决方式：在浏览器的每一帧时间中，会预留一些时间给`JS`线程，`React`会利用这部分时间更新组件（预留时间是`5ms`）。当预留的时间不够时，`React`就会将线程控制权交还给浏览器使其有时间执行渲染流水线的工作，而`React`则会等待下一帧来继续执行被中断的工作。
> 这种将长任务拆分成多段，每次执行一小段的任务的操作，被称为**时间切片**（time slice）

`React`的新模式`Concurrent Mode`（并发模式）就会默认使用**时间切片**（具体可以看[这篇](../architecture/scheduler.md)介绍）这种特性。  
```js
// 通过使用ReactDOM.createRoot开启Concurrent Mode
ReactDOM.createRoot(rootEl).render(<App/>);
```
所以，解决CPU瓶颈的关键是实现**时间切片**，而**时间切片**的关键是：将**同步的更新**变为**异步可中断的更新**。

### IO的瓶颈
对应的网络延迟是前端开发人员无法解决的问题，那么在客观因素的影响下，如何减少用户对网络延迟的感知呢？  

React给处的答案是将`人机交互研究的结果整合到真实的UI中`。  

简单来说，就是在等待的过程中通过显示`loading`效果，来减少用户对网络延迟的感知。  

为此，React对应的实现方式是`Suspense`（具体可以看[这篇](../implement/suspense.md)介绍）以及`useTransition hook`(具体可以看[这篇](../hooks/useTransition.md)介绍)。  

而在源码的内部，为了支持这种特性，React更新的方式也从**同步的更新**变为**异步可中断的更新**。



