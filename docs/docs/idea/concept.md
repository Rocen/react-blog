## React理念

> React 是用 JavaScript 构建**快速响应**的大型 Web 应用程序的首选方式。

所以React的关键实现`快速响应`，那么制约`快速响应`的因素是什么呢？  

在日常使用网页时，有两类场景会制约`快速响应`：
+ 遇到需要大量计算的操作时使页面掉帧，造成卡顿
+ 在发送网络请求时，由于数据传输过程中的往返时延，导致的等待  

这两类场景可以概括为：
+ CPU的瓶颈
+ IO的瓶颈

## React解决方式

### CPU的瓶颈
由于JS可以操作DOM，GUI渲染现成与JS线程是互斥的，所以**JS脚本的执行**和**浏览器布局**、*绘制**是不能同时执行的。  

且电脑屏幕每次刷新的16.6ms内，需要完成：
```
JS脚本执行 --> 样式布局 --> 页面绘制
```
所以，在一帧当中，当JS脚本执行时间过长，显然会导致后续的渲染流水线执行时间缩短，甚至没有时间执行，就造成页面掉帧和用户感知的卡顿。  

解决方式：在浏览器的每一帧时间中，会预留一些时间给JS线程，React会利用这部分时间更新组件（预留时间是5ms）。当预留的时间不够时，React就会将线程控制权交还给浏览器使其有时间执行渲染流水线的工作，而React则会等待下一帧来继续执行被中断的工作。
> 这种将长任务拆分成多段，每次执行一小段的任务的操作，被称为**时间切片**（time slice）

React的新模式`Concurrent Mode`就会默认使用**时间切片**这种特性。

### IO的瓶颈
对应的网络延迟是前端开发人员无法解决的问题，那么在客观因素的影响下，如何减少用户对网络延迟的感知呢？  

React给处的答案是将`人机交互研究的结果整合到真实的UI中`。  

简单来说，就是在等待的过程中通过显示`loading`效果，来减少用户对网络延迟的感知。  

为此，React对应的实现方式是`Suspense`。  

而在源码的内部，为了支持这种特性，React更新的方式也从**同步的更新**变为**异步可中断的更新**。



