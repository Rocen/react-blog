<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>useState和useReducer | React笔记</title>
    <meta name="generator" content="VuePress 1.9.5">
    <link rel="icon" href="/react-blog/logo.svg">
    <meta name="description" content="React">
    
    <link rel="preload" href="/react-blog/assets/css/0.styles.7c9b7da0.css" as="style"><link rel="preload" href="/react-blog/assets/js/app.1296abc1.js" as="script"><link rel="preload" href="/react-blog/assets/js/2.2aa2ea89.js" as="script"><link rel="preload" href="/react-blog/assets/js/34.16302cd1.js" as="script"><link rel="prefetch" href="/react-blog/assets/js/10.eec084d2.js"><link rel="prefetch" href="/react-blog/assets/js/11.90e7ad9c.js"><link rel="prefetch" href="/react-blog/assets/js/12.ec712917.js"><link rel="prefetch" href="/react-blog/assets/js/13.5fd1705f.js"><link rel="prefetch" href="/react-blog/assets/js/14.33d6319e.js"><link rel="prefetch" href="/react-blog/assets/js/15.b49ac970.js"><link rel="prefetch" href="/react-blog/assets/js/16.915d1a33.js"><link rel="prefetch" href="/react-blog/assets/js/17.0d48f94a.js"><link rel="prefetch" href="/react-blog/assets/js/18.162dd664.js"><link rel="prefetch" href="/react-blog/assets/js/19.897cc694.js"><link rel="prefetch" href="/react-blog/assets/js/20.c0d68b54.js"><link rel="prefetch" href="/react-blog/assets/js/21.23f5c8b7.js"><link rel="prefetch" href="/react-blog/assets/js/22.17cddd5f.js"><link rel="prefetch" href="/react-blog/assets/js/23.3e2c069f.js"><link rel="prefetch" href="/react-blog/assets/js/24.16287cbc.js"><link rel="prefetch" href="/react-blog/assets/js/25.c9819b86.js"><link rel="prefetch" href="/react-blog/assets/js/26.03bcf156.js"><link rel="prefetch" href="/react-blog/assets/js/27.2e75196a.js"><link rel="prefetch" href="/react-blog/assets/js/28.71dcfa28.js"><link rel="prefetch" href="/react-blog/assets/js/29.0534c7d4.js"><link rel="prefetch" href="/react-blog/assets/js/3.1f92403b.js"><link rel="prefetch" href="/react-blog/assets/js/30.70a1b1a5.js"><link rel="prefetch" href="/react-blog/assets/js/31.8d8007c6.js"><link rel="prefetch" href="/react-blog/assets/js/32.f55b2b21.js"><link rel="prefetch" href="/react-blog/assets/js/33.dea713d0.js"><link rel="prefetch" href="/react-blog/assets/js/35.58ce8424.js"><link rel="prefetch" href="/react-blog/assets/js/36.21c87dbf.js"><link rel="prefetch" href="/react-blog/assets/js/37.e9ccbb00.js"><link rel="prefetch" href="/react-blog/assets/js/38.eda7b7d3.js"><link rel="prefetch" href="/react-blog/assets/js/39.28c4eb15.js"><link rel="prefetch" href="/react-blog/assets/js/4.ace4b147.js"><link rel="prefetch" href="/react-blog/assets/js/40.13eceae9.js"><link rel="prefetch" href="/react-blog/assets/js/41.e5e3f4ba.js"><link rel="prefetch" href="/react-blog/assets/js/42.1ab022fc.js"><link rel="prefetch" href="/react-blog/assets/js/43.eca03ba8.js"><link rel="prefetch" href="/react-blog/assets/js/44.be104c53.js"><link rel="prefetch" href="/react-blog/assets/js/5.68075c63.js"><link rel="prefetch" href="/react-blog/assets/js/6.01147cc3.js"><link rel="prefetch" href="/react-blog/assets/js/7.630cc1a8.js"><link rel="prefetch" href="/react-blog/assets/js/8.80d0f023.js"><link rel="prefetch" href="/react-blog/assets/js/9.f8d3ba3a.js">
    <link rel="stylesheet" href="/react-blog/assets/css/0.styles.7c9b7da0.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/react-blog/" class="home-link router-link-active"><!----> <span class="site-name">React笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://next-blog.irocen.top" target="_blank" rel="noopener noreferrer" class="nav-link external">
  nextjs笔记
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://github.com/Rocen" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="https://next-blog.irocen.top" target="_blank" rel="noopener noreferrer" class="nav-link external">
  nextjs笔记
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://github.com/Rocen" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><a href="/react-blog/" class="sidebar-heading clickable router-link-active"><span>开始</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/react-blog/docs/start/directory.html" class="sidebar-link">目录</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>理念</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>架构</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>原理</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>概念</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Hooks</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/react-blog/docs/hooks/useStateAnduseReducer.html" aria-current="page" class="active sidebar-link">useState和useReducer</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/react-blog/docs/hooks/useStateAnduseReducer.html#usestate和usereducer" class="sidebar-link">useState和useReducer</a></li><li class="sidebar-sub-header"><a href="/react-blog/docs/hooks/useStateAnduseReducer.html#dispatcher" class="sidebar-link">Dispatcher</a></li><li class="sidebar-sub-header"><a href="/react-blog/docs/hooks/useStateAnduseReducer.html#hooks的数据结构" class="sidebar-link">Hooks的数据结构</a></li><li class="sidebar-sub-header"><a href="/react-blog/docs/hooks/useStateAnduseReducer.html#工作流程" class="sidebar-link">工作流程</a></li><li class="sidebar-sub-header"><a href="/react-blog/docs/hooks/useStateAnduseReducer.html#声明阶段" class="sidebar-link">声明阶段</a></li><li class="sidebar-sub-header"><a href="/react-blog/docs/hooks/useStateAnduseReducer.html#调用阶段" class="sidebar-link">调用阶段</a></li><li class="sidebar-sub-header"><a href="/react-blog/docs/hooks/useStateAnduseReducer.html#总结" class="sidebar-link">总结</a></li></ul></li><li><a href="/react-blog/docs/hooks/useEffect.html" class="sidebar-link">useEffect</a></li><li><a href="/react-blog/docs/hooks/executeUseEffect.html" class="sidebar-link">useEffect的执行</a></li><li><a href="/react-blog/docs/hooks/useRef.html" class="sidebar-link">useRef</a></li><li><a href="/react-blog/docs/hooks/useMemoAnduseCallback.html" class="sidebar-link">useMemo和useCallback</a></li><li><a href="/react-blog/docs/hooks/useTransition.html" class="sidebar-link">useTransition</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Concurrent Mode</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>实现</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>发现</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="usestate和usereducer"><a href="#usestate和usereducer" class="header-anchor">#</a> useState和useReducer</h2> <p>之前在状态更新一节介绍了<code>ClassComponent</code>和<code>HostRoot</code>类型的状态更新方式，接下来再一起看下<code>FunctionComponent</code>类型的状态更新方式。
<code>useState</code>和<code>useReducer</code>都是在<code>FunctionComponent</code>中可以触发状态更新的<code>hooks</code>。</p> <h2 id="dispatcher"><a href="#dispatcher" class="header-anchor">#</a> Dispatcher</h2> <p>在与<code>Hooks</code>相关的源码中有一个非常重要的概念或者说是变量，就是<code>dispatcher</code>。</p> <p>在<code>Hooks</code>中，组件<code>mount</code>时的<code>hook</code>与<code>update</code>时的<code>hook</code>来源于不同的对象，这类对象在源码中被称为<code>dispatcher</code>。<br>
以下是<code>dispatcher</code>在源码中的定义：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> HooksDispatcherOnMount<span class="token operator">:</span> Dispatcher <span class="token operator">=</span> <span class="token punctuation">{</span>
  useCallback<span class="token operator">:</span> mountCallback<span class="token punctuation">,</span>
  useContext<span class="token operator">:</span> readContext<span class="token punctuation">,</span>
  useEffect<span class="token operator">:</span> mountEffect<span class="token punctuation">,</span>
  useImperativeHandle<span class="token operator">:</span> mountImperativeHandle<span class="token punctuation">,</span>
  useLayoutEffect<span class="token operator">:</span> mountLayoutEffect<span class="token punctuation">,</span>
  useMemo<span class="token operator">:</span> mountMemo<span class="token punctuation">,</span>
  useReducer<span class="token operator">:</span> mountReducer<span class="token punctuation">,</span>
  useRef<span class="token operator">:</span> mountRef<span class="token punctuation">,</span>
  useState<span class="token operator">:</span> mountState<span class="token punctuation">,</span>
  <span class="token comment">// ,,,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> HooksDispatcherOnUpdate<span class="token operator">:</span> Dispatcher <span class="token operator">=</span> <span class="token punctuation">{</span>
  useCallback<span class="token operator">:</span> updateCallback<span class="token punctuation">,</span>
  useContext<span class="token operator">:</span> readContext<span class="token punctuation">,</span>
  useEffect<span class="token operator">:</span> updateEffect<span class="token punctuation">,</span>
  useImperativeHandle<span class="token operator">:</span> updateImperativeHandle<span class="token punctuation">,</span>
  useLayoutEffect<span class="token operator">:</span> updateLayoutEffect<span class="token punctuation">,</span>
  useMemo<span class="token operator">:</span> updateMemo<span class="token punctuation">,</span>
  useReducer<span class="token operator">:</span> updateReducer<span class="token punctuation">,</span>
  useRef<span class="token operator">:</span> updateRef<span class="token punctuation">,</span>
  useState<span class="token operator">:</span> updateState<span class="token punctuation">,</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> ContextOnlyDispatcher<span class="token operator">:</span> Dispatcher <span class="token operator">=</span> <span class="token punctuation">{</span>
  useCallback<span class="token operator">:</span> throwInvalidHookError<span class="token punctuation">,</span>
  useContext<span class="token operator">:</span> throwInvalidHookError<span class="token punctuation">,</span>
  useEffect<span class="token operator">:</span> throwInvalidHookError<span class="token punctuation">,</span>
  useImperativeHandle<span class="token operator">:</span> throwInvalidHookError<span class="token punctuation">,</span>
  useLayoutEffect<span class="token operator">:</span> throwInvalidHookError<span class="token punctuation">,</span>
  useMemo<span class="token operator">:</span> throwInvalidHookError<span class="token punctuation">,</span>
  useReducer<span class="token operator">:</span> throwInvalidHookError<span class="token punctuation">,</span>
  useRef<span class="token operator">:</span> throwInvalidHookError<span class="token punctuation">,</span>
  useState<span class="token operator">:</span> throwInvalidHookError<span class="token punctuation">,</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>从这段代码可以看出，<code>Dispatcher</code>一共有三种类型，通常对应了三个变量。而从这三个变量的命名应该大致可以猜到他们的用途。</p> <p><code>FunctionComponent</code>在<code>mount</code>时会使用<code>HooksDispatcherOnMount</code>中属于<code>mount</code>阶段的处理函数，而在<code>update</code>时会使用<code>HooksDispatcherOnUpdate</code>中属于<code>update</code>阶段的处理函数。</p> <p>在<code>FunctionComponent render</code>前，会根据<code>FunctionComponent</code>对应的<code>fiber</code>按如下条件来判断，<code>FunctionComponent</code>属于<code>mount</code>还是<code>update</code>：</p> <div class="language-js extra-class"><pre class="language-js"><code>ReactCurrentDispatcher<span class="token punctuation">.</span>current <span class="token operator">=</span>
  current <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span> current<span class="token punctuation">.</span>memoizedState <span class="token operator">===</span> <span class="token keyword">null</span>
    <span class="token operator">?</span> HooksDispatcherOnMount
    <span class="token operator">:</span> HooksDispatcherOnUpdate<span class="token punctuation">;</span>  
</code></pre></div><p><code>ReactCurrentDispatcher</code>是一个全局变量，用来保存<code>mount</code>和<code>update</code>时对应的<code>dispatcher</code>。</p> <p>其中<code>current</code>变量表示的就是<code>current Fiber</code>。如果<code>current === null</code>就表示当前还没有<code>current Fiber</code>，说明此时是<code>FunctionComponent</code>的第一次渲染，所以就对应<code>mount</code>。</p> <p>当在<code>FunctionComponent</code>中声明了<code>hooks</code>，这些<code>hook</code>会组成单项链表的结构保存在<code>fiber.memoizedState</code>属性上。所以通过<code>current fiber.memoizedState === null</code>就可以判断当前这个<code>Fiber</code>上还不存在<code>hook</code>，所以也对应<code>mount</code>。</p> <p>如果不存在上述两种情况就说明不是<code>mount</code>而是<code>update</code>。那么就需要使用<code>update</code>对应的处理函数了。</p> <p>还有一种抛出异常的<code>dispacher：ContextOnlyDispatcher</code>。<code>ContextOnlyDispatcher</code>就是为了保证在<code>FunctionComponent</code>中使用<code>hooks</code>的方式是正确的。</p> <p>那么<code>ContextOnlyDispatcher</code>会在什么时候赋值给<code>ContextOnlyDispatcher</code>的呢？</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 简化后</span>
<span class="token keyword">function</span> renderWithHooks<span class="token operator">&lt;</span>Props<span class="token punctuation">,</span> SecondArg<span class="token operator">&gt;</span><span class="token punctuation">(</span>
  current<span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  workInProgress<span class="token operator">:</span> Fiber<span class="token punctuation">,</span>
  <span class="token function-variable function">Component</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">p<span class="token operator">:</span> Props<span class="token punctuation">,</span> arg<span class="token operator">:</span> SecondArg</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> any<span class="token punctuation">,</span>
  props<span class="token operator">:</span> Props<span class="token punctuation">,</span>
  secondArg<span class="token operator">:</span> SecondArg<span class="token punctuation">,</span>
  nextRenderLanes<span class="token operator">:</span> Lanes<span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token operator">:</span> any <span class="token punctuation">{</span>

  ReactCurrentDispatcher<span class="token punctuation">.</span>current <span class="token operator">=</span>
      current <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span> current<span class="token punctuation">.</span>memoizedState <span class="token operator">===</span> <span class="token keyword">null</span>
        <span class="token operator">?</span> HooksDispatcherOnMount
        <span class="token operator">:</span> HooksDispatcherOnUpdate<span class="token punctuation">;</span>

  <span class="token keyword">let</span> children <span class="token operator">=</span> <span class="token function">Component</span><span class="token punctuation">(</span>props<span class="token punctuation">,</span> secondArg<span class="token punctuation">)</span><span class="token punctuation">;</span>

  ReactCurrentDispatcher<span class="token punctuation">.</span>current <span class="token operator">=</span> ContextOnlyDispatcher<span class="token punctuation">;</span>

<span class="token punctuation">}</span>
</code></pre></div><p>我们知道在<code>render</code>阶段对于<code>FunctionComponent</code>会通过调用<code>renderWithHooks</code>方法来实现组件的渲染，而在实现组件渲染之前会赋值<code>ReactCurrentDispatcher</code>变量来确保在执行<code>FunctionComponent</code>时，组件内使用的<code>hooks</code>都属于正确的处理函数。而在组件渲染完成之后就会将<code>ReactCurrentDispatcher</code>赋值为<code>ContextOnlyDispatcher</code>。</p> <p>可以考虑如下情况：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p><code>useEffect</code>因为属于顶层的<code>hook</code>，所以在组件渲染时会使用正确的处理函数（<code>mountEffect</code>或<code>updateEffect</code>）。</p> <p>而<code>useState</code>被使用在了<code>useEffect</code>的回调函数中，在执行组件渲染的时候不会被执行的，而会等到<code>useEffect</code>的回调函数在<code>layout</code>阶段之后异步执行。所以当执行<code>useState</code>的时候，此时的全局变量<code>ReactCurrentDispatcher</code>的值已经是<code>ContextOnlyDispatcher</code>，导致<code>useState</code>对应的处理函数就是<code>throwInvalidHookError</code>方法。然后<code>throwInvalidHookError</code>方法就会抛出异常，来警告开发者<code>Hooks</code>的使用方式是不正确的。</p> <h2 id="hooks的数据结构"><a href="#hooks的数据结构" class="header-anchor">#</a> Hooks的数据结构</h2> <p>在学习<code>hooks</code>之前还需要了解<code>hook</code>在源码中是如何定义的。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> hook<span class="token operator">:</span> Hook <span class="token operator">=</span> <span class="token punctuation">{</span>
  memoizedState<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token comment">// 用来保存hook中的变量，如果是useState或useReducer的话，memoizedState保存的就是state的值</span>

  <span class="token comment">// 与ClassComponent和HostRoot类型的updateQueue结构类似</span>
  baseState<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token comment">// baseState</span>
  baseQueue<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token comment">// firstBaseUpdate和update.lastBaseUpdate</span>
  queue<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token comment">// shared.pending</span>

  next<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token comment">// 指针，用来指向下一个hook</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="工作流程"><a href="#工作流程" class="header-anchor">#</a> 工作流程</h2> <p>以如下代码作为示例：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token punctuation">[</span>num<span class="token punctuation">,</span> setNum<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token punctuation">(</span>
        <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
            <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setNum</span><span class="token punctuation">(</span><span class="token parameter">num</span> <span class="token operator">=&gt;</span> num <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>num<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
    <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>useState</code>和<code>useReducer</code>的工作流程可以分为两部分：</p> <ul><li>声明阶段：组件渲染时，会执行<code>useState</code>或<code>useReducer</code>方法</li> <li>调用阶段：触发点击事件，调用<code>setNum</code>方法而触发状态更新</li></ul> <h2 id="声明阶段"><a href="#声明阶段" class="header-anchor">#</a> 声明阶段</h2> <p>在执行组件渲染时，会调用<code>renderWithHooks</code>方法。该方法会执行<code>FunctionComponent</code>来完成组件的渲染。此时遇到<code>useState</code>的话，就会进入声明阶段。</p> <p>在<code>mount</code>时，<code>useState</code>会通过<code>HooksDispatcherOnMount</code>调用<code>mountState</code>方法。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> mountState<span class="token operator">&lt;</span><span class="token constant">S</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>
  initialState<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">S</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token constant">S</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token constant">S</span><span class="token punctuation">,</span> Dispatch<span class="token operator">&lt;</span>BasicStateAction<span class="token operator">&lt;</span><span class="token constant">S</span><span class="token operator">&gt;&gt;</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
  <span class="token comment">// 创建hook</span>
  <span class="token keyword">const</span> hook <span class="token operator">=</span> <span class="token function">mountWorkInProgressHook</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 判断initialState的类型</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> initialState <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果initialState是函数的话，则需要执行这个函数获取执行结果</span>
    initialState <span class="token operator">=</span> <span class="token function">initialState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 保存initialState</span>
  hook<span class="token punctuation">.</span>memoizedState <span class="token operator">=</span> hook<span class="token punctuation">.</span>baseState <span class="token operator">=</span> initialState<span class="token punctuation">;</span>
  <span class="token comment">// 创建queue</span>
  <span class="token keyword">const</span> queue <span class="token operator">=</span> <span class="token punctuation">(</span>hook<span class="token punctuation">.</span>queue <span class="token operator">=</span> <span class="token punctuation">{</span>
    pending<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token comment">// 通过dispatch创建的update会通过环状链表的形式保存在pending上</span>
    lanes<span class="token operator">:</span> NoLanes<span class="token punctuation">,</span> <span class="token comment">// 优先级</span>
    dispatch<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token comment">// 保存dispatchAction.bind()的值</span>
    lastRenderedReducer<span class="token operator">:</span> basicStateReducer<span class="token punctuation">,</span> <span class="token comment">// 上一次render时使用的reducer</span>
    lastRenderedState<span class="token operator">:</span> <span class="token punctuation">(</span>initialState<span class="token operator">:</span> any<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// 上一次render时的state</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 赋值dispatch</span>
  <span class="token keyword">const</span> dispatch<span class="token operator">:</span> Dispatch<span class="token operator">&lt;</span>
    BasicStateAction<span class="token operator">&lt;</span><span class="token constant">S</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
  <span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">(</span>queue<span class="token punctuation">.</span>dispatch <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token function">dispatchAction</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>
    <span class="token keyword">null</span><span class="token punctuation">,</span>
    currentlyRenderingFiber<span class="token punctuation">,</span>
    queue<span class="token punctuation">,</span>
  <span class="token punctuation">)</span><span class="token operator">:</span> any<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 返回结果</span>
  <span class="token keyword">return</span> <span class="token punctuation">[</span>hook<span class="token punctuation">.</span>memoizedState<span class="token punctuation">,</span> dispatch<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">mountWorkInProgressHook</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Hook <span class="token punctuation">{</span>
  <span class="token comment">// 创建hook</span>
  <span class="token keyword">const</span> hook<span class="token operator">:</span> Hook <span class="token operator">=</span> <span class="token punctuation">{</span>
    memoizedState<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>

    baseState<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    baseQueue<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    queue<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>

    next<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token comment">// workInProgressHook是一个全局变量，用来保存当前正在执行的hook</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>workInProgressHook <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 当workInProgressHook为null，说明当前创建的hook是第一个hook</span>
    currentlyRenderingFiber<span class="token punctuation">.</span>memoizedState <span class="token operator">=</span> workInProgressHook <span class="token operator">=</span> hook<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 将创建的hook连接在workInProgressHook链表的末尾</span>
    <span class="token comment">// 并重新赋值workInProgressHook</span>
    workInProgressHook <span class="token operator">=</span> workInProgressHook<span class="token punctuation">.</span>next <span class="token operator">=</span> hook<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 返回</span>
  <span class="token keyword">return</span> workInProgressHook<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>从这段代码可以看到，<code>mountState</code>方法的逻辑比较简单，主要做的就是初始化的工作。</p> <p>其中<code>basicStateReducer</code>方法如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> basicStateReducer<span class="token operator">&lt;</span><span class="token constant">S</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>state<span class="token operator">:</span> <span class="token constant">S</span><span class="token punctuation">,</span> action<span class="token operator">:</span> BasicStateAction<span class="token operator">&lt;</span><span class="token constant">S</span><span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">S</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">typeof</span> action <span class="token operator">===</span> <span class="token string">'function'</span> <span class="token operator">?</span> <span class="token function">action</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token operator">:</span> action<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>由此可见，<code>useState</code>是预置了<code>reducer</code>的<code>useReducer</code>，而这个预置的<code>reducer</code>是<code>basicStateReducer</code>。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> updateState<span class="token operator">&lt;</span><span class="token constant">S</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>
  initialState<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">S</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token constant">S</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token constant">S</span><span class="token punctuation">,</span> Dispatch<span class="token operator">&lt;</span>BasicStateAction<span class="token operator">&lt;</span><span class="token constant">S</span><span class="token operator">&gt;&gt;</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">updateReducer</span><span class="token punctuation">(</span>basicStateReducer<span class="token punctuation">,</span> <span class="token punctuation">(</span>initialState<span class="token operator">:</span> any<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>所以，在<code>update</code>时，<code>useState</code>其实调用的就是<code>updateReducer</code>。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> updateReducer<span class="token operator">&lt;</span><span class="token constant">S</span><span class="token punctuation">,</span> <span class="token constant">I</span><span class="token punctuation">,</span> <span class="token constant">A</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>
  <span class="token function-variable function">reducer</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token constant">S</span><span class="token punctuation">,</span> <span class="token constant">A</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">S</span><span class="token punctuation">,</span>
  initialArg<span class="token operator">:</span> <span class="token constant">I</span><span class="token punctuation">,</span>
  init<span class="token operator">?</span><span class="token operator">:</span> <span class="token parameter"><span class="token constant">I</span></span> <span class="token operator">=&gt;</span> <span class="token constant">S</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token constant">S</span><span class="token punctuation">,</span> Dispatch<span class="token operator">&lt;</span><span class="token constant">A</span><span class="token operator">&gt;</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
  <span class="token comment">// 获取hook</span>
  <span class="token keyword">const</span> hook <span class="token operator">=</span> <span class="token function">updateWorkInProgressHook</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> queue <span class="token operator">=</span> hook<span class="token punctuation">.</span>queue<span class="token punctuation">;</span>
  <span class="token comment">// 重新赋值lastRenderedReducer</span>
  queue<span class="token punctuation">.</span>lastRenderedReducer <span class="token operator">=</span> reducer<span class="token punctuation">;</span>

  <span class="token keyword">const</span> current<span class="token operator">:</span> Hook <span class="token operator">=</span> <span class="token punctuation">(</span>currentHook<span class="token operator">:</span> any<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 以下这部分逻辑与update和updateQueue几乎一致</span>
  <span class="token keyword">let</span> baseQueue <span class="token operator">=</span> current<span class="token punctuation">.</span>baseQueue<span class="token punctuation">;</span>

  <span class="token comment">// 获取pendingQueue</span>
  <span class="token keyword">const</span> pendingQueue <span class="token operator">=</span> queue<span class="token punctuation">.</span>pending<span class="token punctuation">;</span>
  <span class="token comment">// 存在需要计算的update</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>pendingQueue <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// baseQueue不为null，说明之前存在被跳过的update</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>baseQueue <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 将pendingQueue这条环状链表剪开，连接到baseQueue上</span>
      <span class="token comment">// 取到baseQueue上第一个update</span>
      <span class="token keyword">const</span> baseFirst <span class="token operator">=</span> baseQueue<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
      <span class="token comment">// 取到pendingQueue上第一个update</span>
      <span class="token keyword">const</span> pendingFirst <span class="token operator">=</span> pendingQueue<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
      <span class="token comment">// 将pendingQueue上的update连接到baseQueue上</span>
      baseQueue<span class="token punctuation">.</span>next <span class="token operator">=</span> pendingFirst<span class="token punctuation">;</span>
      <span class="token comment">// 再将</span>
      pendingQueue<span class="token punctuation">.</span>next <span class="token operator">=</span> baseFirst<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 赋值一份baseQueue保存到current fiber上</span>
    current<span class="token punctuation">.</span>baseQueue <span class="token operator">=</span> baseQueue <span class="token operator">=</span> pendingQueue<span class="token punctuation">;</span>
    <span class="token comment">// 重置pending</span>
    queue<span class="token punctuation">.</span>pending <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 计算update</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>baseQueue <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 取到第一个update</span>
    <span class="token keyword">const</span> first <span class="token operator">=</span> baseQueue<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token comment">// 取到baseState</span>
    <span class="token keyword">let</span> newState <span class="token operator">=</span> current<span class="token punctuation">.</span>baseState<span class="token punctuation">;</span>

    <span class="token keyword">let</span> newBaseState <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> newBaseQueueFirst <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> newBaseQueueLast <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> update <span class="token operator">=</span> first<span class="token punctuation">;</span>
    <span class="token keyword">do</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> updateLane <span class="token operator">=</span> update<span class="token punctuation">.</span>lane<span class="token punctuation">;</span>
      <span class="token comment">// 当前update因为优先级不够而被跳过</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isSubsetOfLanes</span><span class="token punctuation">(</span>renderLanes<span class="token punctuation">,</span> updateLane<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 克隆update，并保存到newBaseQueue中</span>
        <span class="token keyword">const</span> clone<span class="token operator">:</span> Update<span class="token operator">&lt;</span><span class="token constant">S</span><span class="token punctuation">,</span> <span class="token constant">A</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
          lane<span class="token operator">:</span> updateLane<span class="token punctuation">,</span>
          action<span class="token operator">:</span> update<span class="token punctuation">.</span>action<span class="token punctuation">,</span>
          eagerReducer<span class="token operator">:</span> update<span class="token punctuation">.</span>eagerReducer<span class="token punctuation">,</span>
          eagerState<span class="token operator">:</span> update<span class="token punctuation">.</span>eagerState<span class="token punctuation">,</span>
          next<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token keyword">null</span><span class="token operator">:</span> any<span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>newBaseQueueLast <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          newBaseQueueFirst <span class="token operator">=</span> newBaseQueueLast <span class="token operator">=</span> clone<span class="token punctuation">;</span>
          newBaseState <span class="token operator">=</span> newState<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
          newBaseQueueLast <span class="token operator">=</span> newBaseQueueLast<span class="token punctuation">.</span>next <span class="token operator">=</span> clone<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 合并优先级</span>
        currentlyRenderingFiber<span class="token punctuation">.</span>lanes <span class="token operator">=</span> <span class="token function">mergeLanes</span><span class="token punctuation">(</span>
          currentlyRenderingFiber<span class="token punctuation">.</span>lanes<span class="token punctuation">,</span>
          updateLane<span class="token punctuation">,</span>
        <span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 当前的update有足够的优先级，可以计算</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>newBaseQueueLast <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">// newBaseQueueLast不为null，说明已经存在被跳过的update，为了保证依赖关系的正确，被跳过的update之后所有的update都要被计算</span>
          <span class="token keyword">const</span> clone<span class="token operator">:</span> Update<span class="token operator">&lt;</span><span class="token constant">S</span><span class="token punctuation">,</span> <span class="token constant">A</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
            lane<span class="token operator">:</span> NoLane<span class="token punctuation">,</span>
            action<span class="token operator">:</span> update<span class="token punctuation">.</span>action<span class="token punctuation">,</span>
            eagerReducer<span class="token operator">:</span> update<span class="token punctuation">.</span>eagerReducer<span class="token punctuation">,</span>
            eagerState<span class="token operator">:</span> update<span class="token punctuation">.</span>eagerState<span class="token punctuation">,</span>
            next<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token keyword">null</span><span class="token operator">:</span> any<span class="token punctuation">)</span><span class="token punctuation">,</span>
          <span class="token punctuation">}</span><span class="token punctuation">;</span>
          <span class="token comment">// 连接到newBaseQueue上</span>
          newBaseQueueLast <span class="token operator">=</span> newBaseQueueLast<span class="token punctuation">.</span>next <span class="token operator">=</span> clone<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 计算update</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>update<span class="token punctuation">.</span>eagerReducer <span class="token operator">===</span> reducer<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">// eagerState会被提前计算，如果已经计算了eagerState，则直接使用</span>
          newState <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>update<span class="token punctuation">.</span>eagerState<span class="token operator">:</span> any<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">S</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
          <span class="token comment">// 从update中取到参数action</span>
          <span class="token keyword">const</span> action <span class="token operator">=</span> update<span class="token punctuation">.</span>action<span class="token punctuation">;</span>
          <span class="token comment">// 执行reducer得到新的state</span>
          newState <span class="token operator">=</span> <span class="token function">reducer</span><span class="token punctuation">(</span>newState<span class="token punctuation">,</span> action<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// 移动next指针，取到下一个update</span>
      update <span class="token operator">=</span> update<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>update <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> update <span class="token operator">!==</span> first<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 如果不存在被跳过的update</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>newBaseQueueLast <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// newBaseState就是newState，否则newBaseState是被跳过的update它所对应的newState</span>
      newBaseState <span class="token operator">=</span> newState<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// 如果存在被跳过的update，将newBaseQueue连成环状链表</span>
      newBaseQueueLast<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token punctuation">(</span>newBaseQueueFirst<span class="token operator">:</span> any<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 赋值memoizedState</span>
    hook<span class="token punctuation">.</span>memoizedState <span class="token operator">=</span> newState<span class="token punctuation">;</span>
    <span class="token comment">// 最终被跳过的update对应的newBaseState会赋值给baseState</span>
    hook<span class="token punctuation">.</span>baseState <span class="token operator">=</span> newBaseState<span class="token punctuation">;</span>
    <span class="token comment">// 被跳过的update队列</span>
    hook<span class="token punctuation">.</span>baseQueue <span class="token operator">=</span> newBaseQueueLast<span class="token punctuation">;</span>

    queue<span class="token punctuation">.</span>lastRenderedState <span class="token operator">=</span> newState<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">const</span> dispatch<span class="token operator">:</span> Dispatch<span class="token operator">&lt;</span><span class="token constant">A</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">(</span>queue<span class="token punctuation">.</span>dispatch<span class="token operator">:</span> any<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 返回memoizedState和dispatch</span>
  <span class="token keyword">return</span> <span class="token punctuation">[</span>hook<span class="token punctuation">.</span>memoizedState<span class="token punctuation">,</span> dispatch<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>整个流程可以概括为：</p> <blockquote><p>找到对应的hook，根据update计算该hook对应的新的state并返回</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">updateWorkInProgressHook</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Hook <span class="token punctuation">{</span>
  <span class="token keyword">let</span> nextCurrentHook<span class="token operator">:</span> <span class="token keyword">null</span> <span class="token operator">|</span> Hook<span class="token punctuation">;</span>
  <span class="token comment">// currentHook是一个全局变量，通常指current fiber上的hook</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>currentHook <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 当currentHook为null，说明此时是update时第一次进入该函数，因为每次调用完renderWithHooks方法，currentHook会置为null</span>
    <span class="token comment">// 通过workInProgress fiber.alternate属性取到current fiber</span>
    <span class="token keyword">const</span> current <span class="token operator">=</span> currentlyRenderingFiber<span class="token punctuation">.</span>alternate<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 存在current fiber</span>
      <span class="token comment">// 将current fiber上第一个hook赋值给nextCurrentHook</span>
      nextCurrentHook <span class="token operator">=</span> current<span class="token punctuation">.</span>memoizedState<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// 不存在current fiber</span>
      <span class="token comment">// nextCurrentHook为null</span>
      nextCurrentHook <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// currentHook不为null，说明不是update时第一次进入该函数</span>
    <span class="token comment">// 则currentHook有值，取下一个currenHook</span>
    nextCurrentHook <span class="token operator">=</span> currentHook<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">let</span> nextWorkInProgressHook<span class="token operator">:</span> <span class="token keyword">null</span> <span class="token operator">|</span> Hook<span class="token punctuation">;</span>
  <span class="token comment">// workInProgressHook是一个全局变量，用来记录当前正在执行的hook</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>workInProgressHook <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 当workInProgressHook为null，说明当前没有正在执行的hook，所以应该从第一个hook开始执行，即workInProgress fiber.memoizedState</span>
    nextWorkInProgressHook <span class="token operator">=</span> currentlyRenderingFiber<span class="token punctuation">.</span>memoizedState<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 否则移动next指针，寻找下一个workInProgressHook</span>
    nextWorkInProgressHook <span class="token operator">=</span> workInProgressHook<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  
  <span class="token keyword">if</span> <span class="token punctuation">(</span>nextWorkInProgressHook <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// nextWorkInProgressHook有值</span>
    <span class="token comment">// 赋值workInProgressHook</span>
    workInProgressHook <span class="token operator">=</span> nextWorkInProgressHook<span class="token punctuation">;</span>
    <span class="token comment">// 移动next指针，取到下一个workInProgressHook</span>
    nextWorkInProgressHook <span class="token operator">=</span> workInProgressHook<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token comment">// 赋值currentHook</span>
    currentHook <span class="token operator">=</span> nextCurrentHook<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// nextWorkInProgressHook没有值</span>
    <span class="token comment">// 赋值currentHook</span>
    currentHook <span class="token operator">=</span> nextCurrentHook<span class="token punctuation">;</span>
    <span class="token comment">// 从currentHook上复制一个hook</span>
    <span class="token keyword">const</span> newHook<span class="token operator">:</span> Hook <span class="token operator">=</span> <span class="token punctuation">{</span>
      memoizedState<span class="token operator">:</span> currentHook<span class="token punctuation">.</span>memoizedState<span class="token punctuation">,</span>

      baseState<span class="token operator">:</span> currentHook<span class="token punctuation">.</span>baseState<span class="token punctuation">,</span>
      baseQueue<span class="token operator">:</span> currentHook<span class="token punctuation">.</span>baseQueue<span class="token punctuation">,</span>
      queue<span class="token operator">:</span> currentHook<span class="token punctuation">.</span>queue<span class="token punctuation">,</span>

      next<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>workInProgressHook <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 当workInProgressHook为null</span>
      <span class="token comment">// 复制的新hook作为workInProgressHook的值</span>
      currentlyRenderingFiber<span class="token punctuation">.</span>memoizedState <span class="token operator">=</span> workInProgressHook <span class="token operator">=</span> newHook<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// 当workInProgressHook不为null</span>
      <span class="token comment">// 将这个复制的新hook连接到workInProgressHook链表的末尾</span>
      workInProgressHook <span class="token operator">=</span> workInProgressHook<span class="token punctuation">.</span>next <span class="token operator">=</span> newHook<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> workInProgressHook<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>从这段代码可以看到，当组件在<code>update</code>时获取<code>hook</code>方式是通过移动<code>workInProgress</code>构成的链表上的<code>next</code>指针获得的。而<code>workInProgress</code>构成的单项链表决定了各个<code>hook</code>存在顺序是固定的，所以这也是为什么在组件中使用<code>hook</code>时的一大限制就是不可以用在<em>条件语句</em>中。</p> <p>因为如果在条件语句中使用了<code>hook</code>，那么在<code>update</code>时就会打乱了<code>hook</code>之间的顺序关系，而各个<code>hook</code>结构中保存的数据结构也不一样，自然就无法混用了。</p> <h2 id="调用阶段"><a href="#调用阶段" class="header-anchor">#</a> 调用阶段</h2> <p>调用阶段通常是在我们使用<code>useState</code>暴露出来的<code>dispatch</code>方法，所以当我们使用了<code>dispatch</code>方法就会进入调用阶段。而这个<code>dispatch</code>方法对应的就是<code>dispatchAction</code>函数：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 简化后的代码</span>
<span class="token keyword">function</span> dispatchAction<span class="token operator">&lt;</span><span class="token constant">S</span><span class="token punctuation">,</span> <span class="token constant">A</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>
  fiber<span class="token operator">:</span> Fiber<span class="token punctuation">,</span>
  queue<span class="token operator">:</span> UpdateQueue<span class="token operator">&lt;</span><span class="token constant">S</span><span class="token punctuation">,</span> <span class="token constant">A</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
  action<span class="token operator">:</span> <span class="token constant">A</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 优先级相关</span>
  <span class="token keyword">const</span> eventTime <span class="token operator">=</span> <span class="token function">requestEventTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> lane <span class="token operator">=</span> <span class="token function">requestUpdateLane</span><span class="token punctuation">(</span>fiber<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 创建update</span>
  <span class="token keyword">const</span> update<span class="token operator">:</span> Update<span class="token operator">&lt;</span><span class="token constant">S</span><span class="token punctuation">,</span> <span class="token constant">A</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    lane<span class="token punctuation">,</span> <span class="token comment">// 优先级</span>
    action<span class="token punctuation">,</span> <span class="token comment">// 指就是在使用dispatch方法时传入的参数，基础类型或函数</span>
    eagerReducer<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token comment">// 特定情况下的优化字段</span>
    eagerState<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token comment">// 特定情况下的优化字段</span>
    next<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token keyword">null</span><span class="token operator">:</span> any<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// 指针，指向下一个update，由此形成环状链表</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token comment">// 取到与workInProgress fiber通过alternate属性连接的fiber（一般为current fiber）</span>
  <span class="token keyword">const</span> alternate <span class="token operator">=</span> fiber<span class="token punctuation">.</span>alternate<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>
    fiber <span class="token operator">===</span> currentlyRenderingFiber <span class="token operator">||</span>
    <span class="token punctuation">(</span>alternate <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> alternate <span class="token operator">===</span> currentlyRenderingFiber<span class="token punctuation">)</span>
  <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// render阶段触发的更新...</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 取到pending</span>
    <span class="token keyword">const</span> pending <span class="token operator">=</span> queue<span class="token punctuation">.</span>pending<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>pending <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 当pending为null时，说明还不存在update，此时创建的update是第一个update，所以这个update需要与自己连接形成环状链表，所以next指针指向自己</span>
      update<span class="token punctuation">.</span>next <span class="token operator">=</span> update<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// 当pending不为null，说明已经存在一个以上的update，所以将update插入到这条环状链表中</span>
      update<span class="token punctuation">.</span>next <span class="token operator">=</span> pending<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
      pending<span class="token punctuation">.</span>next <span class="token operator">=</span> update<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// queue.pending始终指向最后一个插入的update</span>
    queue<span class="token punctuation">.</span>pending <span class="token operator">=</span> update<span class="token punctuation">;</span>

    <span class="token comment">// eagerState相关的优化逻辑...</span>

    <span class="token comment">// 调度状态更新</span>
    <span class="token keyword">const</span> root <span class="token operator">=</span> <span class="token function">scheduleUpdateOnFiber</span><span class="token punctuation">(</span>fiber<span class="token punctuation">,</span> lane<span class="token punctuation">,</span> eventTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>从这段代码可以看到，<code>dispatchAction</code>方法主要做的工作就是创建<code>update</code>，并将<code>update</code>插入到<code>queue.pending</code>构成的环状链表中，然后开启调度状态更新。</p> <p>其中与<code>eagerState</code>相关的优化逻辑的详细介绍可以看<a href="/react-blog/docs/find/performanceOptimize.html">这篇</a>文章。</p> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <p><code>useState</code>和<code>useReducer</code>的工作流程可以分为两步：</p> <ul><li>声明阶段：组件渲染时，会执行<code>useState</code>或<code>useReducer</code>方法</li> <li>调用阶段：调用<code>dispatch</code>方法而触发状态更新</li></ul> <p>并且<code>useState</code>和<code>useReducer</code>在源码实现上可以说非常相似，区别在于<code>useState</code>是<code>React</code>内置了<code>reducer</code>方法，而<code>useReducer</code>可以自定义<code>reducer</code>方法。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/react-blog/docs/concept/errorBoundary.html" class="prev">
        错误边界
      </a></span> <span class="next"><a href="/react-blog/docs/hooks/useEffect.html">
        useEffect
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/react-blog/assets/js/app.1296abc1.js" defer></script><script src="/react-blog/assets/js/2.2aa2ea89.js" defer></script><script src="/react-blog/assets/js/34.16302cd1.js" defer></script>
  </body>
</html>
