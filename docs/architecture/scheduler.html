<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Scheduler（调度器） | React笔记</title>
    <meta name="generator" content="VuePress 1.9.5">
    <link rel="icon" href="/react-blog/logo.svg">
    <meta name="description" content="React">
    
    <link rel="preload" href="/react-blog/assets/css/0.styles.7c9b7da0.css" as="style"><link rel="preload" href="/react-blog/assets/js/app.1296abc1.js" as="script"><link rel="preload" href="/react-blog/assets/js/2.2aa2ea89.js" as="script"><link rel="preload" href="/react-blog/assets/js/17.0d48f94a.js" as="script"><link rel="prefetch" href="/react-blog/assets/js/10.eec084d2.js"><link rel="prefetch" href="/react-blog/assets/js/11.90e7ad9c.js"><link rel="prefetch" href="/react-blog/assets/js/12.ec712917.js"><link rel="prefetch" href="/react-blog/assets/js/13.5fd1705f.js"><link rel="prefetch" href="/react-blog/assets/js/14.33d6319e.js"><link rel="prefetch" href="/react-blog/assets/js/15.b49ac970.js"><link rel="prefetch" href="/react-blog/assets/js/16.915d1a33.js"><link rel="prefetch" href="/react-blog/assets/js/18.162dd664.js"><link rel="prefetch" href="/react-blog/assets/js/19.897cc694.js"><link rel="prefetch" href="/react-blog/assets/js/20.c0d68b54.js"><link rel="prefetch" href="/react-blog/assets/js/21.23f5c8b7.js"><link rel="prefetch" href="/react-blog/assets/js/22.17cddd5f.js"><link rel="prefetch" href="/react-blog/assets/js/23.3e2c069f.js"><link rel="prefetch" href="/react-blog/assets/js/24.16287cbc.js"><link rel="prefetch" href="/react-blog/assets/js/25.c9819b86.js"><link rel="prefetch" href="/react-blog/assets/js/26.03bcf156.js"><link rel="prefetch" href="/react-blog/assets/js/27.2e75196a.js"><link rel="prefetch" href="/react-blog/assets/js/28.71dcfa28.js"><link rel="prefetch" href="/react-blog/assets/js/29.0534c7d4.js"><link rel="prefetch" href="/react-blog/assets/js/3.1f92403b.js"><link rel="prefetch" href="/react-blog/assets/js/30.70a1b1a5.js"><link rel="prefetch" href="/react-blog/assets/js/31.8d8007c6.js"><link rel="prefetch" href="/react-blog/assets/js/32.f55b2b21.js"><link rel="prefetch" href="/react-blog/assets/js/33.dea713d0.js"><link rel="prefetch" href="/react-blog/assets/js/34.16302cd1.js"><link rel="prefetch" href="/react-blog/assets/js/35.58ce8424.js"><link rel="prefetch" href="/react-blog/assets/js/36.21c87dbf.js"><link rel="prefetch" href="/react-blog/assets/js/37.e9ccbb00.js"><link rel="prefetch" href="/react-blog/assets/js/38.eda7b7d3.js"><link rel="prefetch" href="/react-blog/assets/js/39.28c4eb15.js"><link rel="prefetch" href="/react-blog/assets/js/4.ace4b147.js"><link rel="prefetch" href="/react-blog/assets/js/40.13eceae9.js"><link rel="prefetch" href="/react-blog/assets/js/41.e5e3f4ba.js"><link rel="prefetch" href="/react-blog/assets/js/42.1ab022fc.js"><link rel="prefetch" href="/react-blog/assets/js/43.eca03ba8.js"><link rel="prefetch" href="/react-blog/assets/js/44.be104c53.js"><link rel="prefetch" href="/react-blog/assets/js/5.68075c63.js"><link rel="prefetch" href="/react-blog/assets/js/6.01147cc3.js"><link rel="prefetch" href="/react-blog/assets/js/7.630cc1a8.js"><link rel="prefetch" href="/react-blog/assets/js/8.80d0f023.js"><link rel="prefetch" href="/react-blog/assets/js/9.f8d3ba3a.js">
    <link rel="stylesheet" href="/react-blog/assets/css/0.styles.7c9b7da0.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/react-blog/" class="home-link router-link-active"><!----> <span class="site-name">React笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://next-blog.irocen.top" target="_blank" rel="noopener noreferrer" class="nav-link external">
  nextjs笔记
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://github.com/Rocen" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="https://next-blog.irocen.top" target="_blank" rel="noopener noreferrer" class="nav-link external">
  nextjs笔记
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://github.com/Rocen" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><a href="/react-blog/" class="sidebar-heading clickable router-link-active"><span>开始</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/react-blog/docs/start/directory.html" class="sidebar-link">目录</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>理念</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>架构</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/react-blog/docs/architecture/scheduler.html" aria-current="page" class="active sidebar-link">Scheduler（调度器）</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/react-blog/docs/architecture/scheduler.html#scheduler-调度器" class="sidebar-link">Scheduler（调度器）</a></li><li class="sidebar-sub-header"><a href="/react-blog/docs/architecture/scheduler.html#时间切片原理" class="sidebar-link">时间切片原理</a></li><li class="sidebar-sub-header"><a href="/react-blog/docs/architecture/scheduler.html#优先级调度" class="sidebar-link">优先级调度</a></li><li class="sidebar-sub-header"><a href="/react-blog/docs/architecture/scheduler.html#优先级的意义" class="sidebar-link">优先级的意义</a></li><li class="sidebar-sub-header"><a href="/react-blog/docs/architecture/scheduler.html#不同优先级任务的排序" class="sidebar-link">不同优先级任务的排序</a></li><li class="sidebar-sub-header"><a href="/react-blog/docs/architecture/scheduler.html#shouldyield" class="sidebar-link">shouldYield</a></li><li class="sidebar-sub-header"><a href="/react-blog/docs/architecture/scheduler.html#暂停到恢复的完整流程" class="sidebar-link">暂停到恢复的完整流程</a></li><li class="sidebar-sub-header"><a href="/react-blog/docs/architecture/scheduler.html#总结" class="sidebar-link">总结</a></li></ul></li><li><a href="/react-blog/docs/architecture/reconciler.html" class="sidebar-link">Reconciler（协调器）</a></li><li><a href="/react-blog/docs/architecture/renderer.html" class="sidebar-link">Renderer（渲染器）</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>原理</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>概念</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Hooks</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Concurrent Mode</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>实现</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>发现</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="scheduler-调度器"><a href="#scheduler-调度器" class="header-anchor">#</a> Scheduler（调度器）</h2> <p><code>Scheduler</code>是新版本<code>React</code>新增的架构，从名字就可以看出它的功能主要就是”调度“。<br>
而<code>Scheduler</code>主要包含两个功能：</p> <ol><li>时间切片</li> <li>优先级调度</li></ol> <p>在理念这一节中介绍了，有两种场景会制约快速响应，其中之一是CPU的瓶颈会造成页面卡顿。所以为了解决CPU瓶颈造成的问题，就要使用时间切片这一特性。而实现时间切片的关键在于，浏览器是否有剩余时间作为任务中断的标准，那么我们需要一种机制，当浏览器有剩余时间时通知我们。
虽然目前已经有了这样一个原生API：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback" target="_blank" rel="noopener noreferrer">requestIdleCallback<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。但由于以下限制，<code>React</code>并没有直接使用这个API。</p> <ul><li>浏览器兼容性</li> <li>触发频率不稳定，比如在浏览器中切换Tab页后，之前注册的<code>requestIdleCallback</code>触发频率就会变低</li></ul> <p>基于以上的原因，<code>React</code>实现了功能更完备的<code>requestIdleCallback</code>的<em>polyfill</em>实现，这就是<code>Scheduler</code>。所以<code>Scheduler</code>最大的作用就是实现<strong>时间切片</strong>。</p> <h2 id="时间切片原理"><a href="#时间切片原理" class="header-anchor">#</a> 时间切片原理</h2> <p>时间切片的本质就是模拟实现<code>requestIdleCallback</code>。</p> <p>所以<code>Scheduler</code>将要使用的回调函数作为<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MessageChannel" target="_blank" rel="noopener noreferrer">Message Channel<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>的回调函数执行。如果宿主环境不支持<code>Message Channel</code>，则会降级使用<code>setTimeout</code>。在此可以看出，<code>Scheduler</code>的时间切片功能是通过<strong>宏任务</strong>实现的。而原因是，在一帧当中<strong>宏任务</strong>的执行时机是<strong>最靠前</strong>的，JS任务尽早的执行就可以留出足够的时间去执行页面渲染流水线的工作。</p> <p>在<code>React</code>的<code>render</code>阶段，开启<code>Concurrent Mode</code>时，每次<code>while</code>遍历时，都会通过<code>Scheduler</code>提供的<code>shouldYield</code>方法判断是否需要<strong>中断遍历</strong>，使浏览器有足够的时间进行渲染。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">workLoopConcurrent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>workInProgress <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">shouldYield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">performUnitOfWork</span><span class="token punctuation">(</span>workInProgress<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>是否中断的依据就是每个任务的<strong>剩余时间</strong>是否用完。</p> <p>所以，在Scheduler中，为任务分配的初始剩余时间为<code>5ms</code>。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">shouldYieldToHost</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// getCurrentTime用来获取当前时间</span>
  <span class="token comment">// deadline表示当前的截止时间</span>
  <span class="token comment">// 如果当前时间大于等于截止时间，说明已经过了时间切片所预留的时间来执行任务，应该暂停任务的执行，返回true</span>
  <span class="token comment">// 反之，说明还没过时间切片所预留的时间，可以执行任务，返回false</span>
  <span class="token keyword">return</span> <span class="token function">getCurrentTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span> deadline<span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
</code></pre></div><p>在每次进入<em>时间切片</em>时，都会进行赋值<code>deadline = currentTime + yieldInterval</code>，而这个<code>yieldInterval</code>通常为<em>5ms</em>，所以每次任务的执行事件都会是多余<em>5ms</em>的一小段时间。</p> <h2 id="优先级调度"><a href="#优先级调度" class="header-anchor">#</a> 优先级调度</h2> <p><code>Scheduler</code>对外暴露了一个方法<code>unstable_runWithPriority</code>。这个方法接受一个优先级与一个回调函数，在回调函数内部调用获取优先级的方法都会取得第一个参数对应的优先级：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">unstable_runWithPriority</span><span class="token punctuation">(</span><span class="token parameter">priorityLevel<span class="token punctuation">,</span> eventHandler</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">switch</span> <span class="token punctuation">(</span>priorityLevel<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> ImmediatePriority<span class="token operator">:</span>
    <span class="token keyword">case</span> UserBlockingPriority<span class="token operator">:</span>
    <span class="token keyword">case</span> NormalPriority<span class="token operator">:</span>
    <span class="token keyword">case</span> LowPriority<span class="token operator">:</span>
    <span class="token keyword">case</span> IdlePriority<span class="token operator">:</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token keyword">default</span><span class="token operator">:</span>
      priorityLevel <span class="token operator">=</span> NormalPriority<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">var</span> previousPriorityLevel <span class="token operator">=</span> currentPriorityLevel<span class="token punctuation">;</span>
  currentPriorityLevel <span class="token operator">=</span> priorityLevel<span class="token punctuation">;</span>

  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">eventHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
    currentPriorityLevel <span class="token operator">=</span> previousPriorityLevel<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>从这段代码可以看到，<code>Scheduler</code>内部存在5种优先级。</p> <p>在<code>React</code>内部凡是涉及到优先级调度的地方，都会使用<code>unstable_runWithPriority</code>。</p> <p>比如，<code>commit</code>阶段是同步执行的。而<code>commit</code>阶段的起点<code>commitRoot</code>方法的优先级为<code>ImmediateSchedulerPriority</code>。</p> <p><code>ImmediateSchedulerPriority</code>即<code>ImmediatePriority</code>的别名，为最高优先级，所以会立刻执行。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">commitRoot</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> renderPriorityLevel <span class="token operator">=</span> <span class="token function">getCurrentPriorityLevel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">runWithPriority</span><span class="token punctuation">(</span>
    ImmediateSchedulerPriority<span class="token punctuation">,</span>
    <span class="token function">commitRootImpl</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> root<span class="token punctuation">,</span> renderPriorityLevel<span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="优先级的意义"><a href="#优先级的意义" class="header-anchor">#</a> 优先级的意义</h2> <p><code>Scheduler</code>对外暴露的最重要的方法是<code>unstable_scheduleCallback</code>。该方法用于以某个优先级注册回调函数。</p> <p>比如，在<code>React</code>中，在<code>commit</code>阶段的<code>beforeMutation</code>阶段会调度<code>useEffect</code>的回调。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>rootDoesHavePassiveEffects<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    rootDoesHavePassiveEffects <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token function">scheduleCallback</span><span class="token punctuation">(</span>NormalSchedulerPriority<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token function">flushPassiveEffects</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里的回调便是通过<code>scheduleCallback</code>调度的，优先级为<code>NormalSchedulerPriority</code>，即<code>NormalPriority</code>。</p> <p>不同的优先级意味任务过期时间：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 立刻过期</span>
<span class="token keyword">var</span> <span class="token constant">IMMEDIATE_PRIORITY_TIMEOUT</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token comment">// 最终过期</span>
<span class="token keyword">var</span> <span class="token constant">USER_BLOCKING_PRIORITY_TIMEOUT</span> <span class="token operator">=</span> <span class="token number">250</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> <span class="token constant">NORMAL_PRIORITY_TIMEOUT</span> <span class="token operator">=</span> <span class="token number">5000</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> <span class="token constant">LOW_PRIORITY_TIMEOUT</span> <span class="token operator">=</span> <span class="token number">10000</span><span class="token punctuation">;</span>
<span class="token comment">// 永不会过期</span>
<span class="token keyword">var</span> <span class="token constant">IDLE_PRIORITY_TIMEOUT</span> <span class="token operator">=</span> maxSigned31BitInt<span class="token punctuation">;</span>


<span class="token keyword">var</span> timeout<span class="token punctuation">;</span> <span class="token comment">// 延迟时间</span>
<span class="token keyword">switch</span> <span class="token punctuation">(</span>priorityLevel<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">case</span> ImmediatePriority<span class="token operator">:</span>
    timeout <span class="token operator">=</span> <span class="token constant">IMMEDIATE_PRIORITY_TIMEOUT</span><span class="token punctuation">;</span>
    <span class="token keyword">break</span><span class="token punctuation">;</span>
  <span class="token keyword">case</span> UserBlockingPriority<span class="token operator">:</span>
    timeout <span class="token operator">=</span> <span class="token constant">USER_BLOCKING_PRIORITY_TIMEOUT</span><span class="token punctuation">;</span>
    <span class="token keyword">break</span><span class="token punctuation">;</span>
  <span class="token keyword">case</span> IdlePriority<span class="token operator">:</span>
    timeout <span class="token operator">=</span> <span class="token constant">IDLE_PRIORITY_TIMEOUT</span><span class="token punctuation">;</span>
    <span class="token keyword">break</span><span class="token punctuation">;</span>
  <span class="token keyword">case</span> LowPriority<span class="token operator">:</span>
    timeout <span class="token operator">=</span> <span class="token constant">LOW_PRIORITY_TIMEOUT</span><span class="token punctuation">;</span>
    <span class="token keyword">break</span><span class="token punctuation">;</span>
  <span class="token keyword">case</span> NormalPriority<span class="token operator">:</span>
  <span class="token keyword">default</span><span class="token operator">:</span>
    timeout <span class="token operator">=</span> <span class="token constant">NORMAL_PRIORITY_TIMEOUT</span><span class="token punctuation">;</span>
    <span class="token keyword">break</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> expirationTime <span class="token operator">=</span> startTime <span class="token operator">+</span> timeout<span class="token punctuation">;</span> <span class="token comment">// 开始时间和延迟时间相加，等于过期时间</span>
</code></pre></div><p>从这段代码可以看到，如果一个任务的优先级是<code>ImmediatePriority</code>，它对应的<code>timeout</code>是 <strong>-1</strong>，通过它计算的过期时间就是<strong>startTime - 1</strong>，说明这个任务马上就过期了，需要立即执行。<br></p> <h2 id="不同优先级任务的排序"><a href="#不同优先级任务的排序" class="header-anchor">#</a> 不同优先级任务的排序</h2> <p>我们已经知道了优先级意味着任务的过期时间。所以当某一时刻，存在很多个不同优先级的任务，每个任务对应着不同的过期时间。</p> <p>这些任务会按照过期时间分为两种：</p> <ul><li><strong>已经过期</strong>的任务</li> <li><strong>还未过期</strong>的任务</li></ul> <p>所以，与之对应的，<code>Scheduler</code>也存在两个队列</p> <ul><li>timerQueue：保存还未过期任务的队列</li> <li>taskQueue：保存已经过期任务的队列</li></ul> <p>每当有新的还未过期的任务被注册，会将其插入到<code>timerQueue</code>中并根据开始时间重新排序<code>timerQueue</code>中任务的顺序。</p> <p>而当<code>timerQueue</code>中有任务就绪时，即<code>startTime &lt;= currentTime</code>，则将这个过期的任务取出再插入到<code>taskQueue</code>中。然后，再从<code>taskQueue</code>中取出最早过期的任务并执行它。</p> <p>为了能在<code>O(1)</code>复杂找到两个队列中时间最早的那个任务，<code>Scheduler</code>使用<em>小顶堆</em>实现了优先级队列。</p> <p>至此，我们通过文字叙述的方式大致了解了<code>Scheduler</code>的实现。</p> <h2 id="shouldyield"><a href="#shouldyield" class="header-anchor">#</a> shouldYield</h2> <p>那么当<code>shouldYield</code>为<code>true</code>时，<code>performUnitOfWork</code>被中断后又是如何恢复的呢？</p> <p>在执行<code>taskQueue</code>中过期任务的方法<code>workLoop</code>中有一处关键步骤：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">workLoop</span><span class="token punctuation">(</span><span class="token parameter">hasTimeRemaining<span class="token punctuation">,</span> initialTime</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// order code...</span>

    <span class="token comment">// 取出callback回调函数，这个是使用scheduleCallback方法传入的第二个参数</span>
    <span class="token keyword">const</span> callback <span class="token operator">=</span> currentTask<span class="token punctuation">.</span>callback<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> callback <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 先重置callback</span>
      currentTask<span class="token punctuation">.</span>callback <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
      <span class="token comment">// 设置优先级</span>
      currentPriorityLevel <span class="token operator">=</span> currentTask<span class="token punctuation">.</span>priorityLevel<span class="token punctuation">;</span>
      <span class="token keyword">const</span> didUserCallbackTimeout <span class="token operator">=</span> currentTask<span class="token punctuation">.</span>expirationTime <span class="token operator">&lt;=</span> currentTime<span class="token punctuation">;</span>
      <span class="token comment">// 执行callback，并取到执行结果</span>
      <span class="token keyword">const</span> continuationCallback <span class="token operator">=</span> <span class="token function">callback</span><span class="token punctuation">(</span>didUserCallbackTimeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
      currentTime <span class="token operator">=</span> <span class="token function">getCurrentTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// **重点**</span>
      <span class="token comment">// 判断执行结果的返回值</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> continuationCallback <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果返回值依然是一个函数</span>
        <span class="token comment">// 重新赋值callback属性</span>
        currentTask<span class="token punctuation">.</span>callback <span class="token operator">=</span> continuationCallback<span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果返回值不是一个函数，通常为null</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>currentTask <span class="token operator">===</span> <span class="token function">peek</span><span class="token punctuation">(</span>taskQueue<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">// 说明这个任务已经执行完毕了，将这个任务从taskQueue中移除</span>
          <span class="token function">pop</span><span class="token punctuation">(</span>taskQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// 继续从timerQueue中取出过期的任务</span>
      <span class="token function">advanceTimers</span><span class="token punctuation">(</span>currentTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// 如果callback不是一个函数，则直接从taskQueue中移除这个任务</span>
      <span class="token function">pop</span><span class="token punctuation">(</span>taskQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// order code...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>当注册的回调函数执行后的返回值<code>continuationCallback</code>为<code>function</code>类型，会将<code>continuationCallback</code>再次作为当前任务的回调函数。</p> <p>那什么时候执行完函数之后依然会返回一个函数作为结果呢？</p> <p><code>render</code>阶段被调度的函数为<code>performConcurrentWorkOnRoot</code>，在该函数末尾有这样一段代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">performConcurrentWorkOnRoot</span><span class="token punctuation">(</span><span class="token parameter">root<span class="token punctuation">,</span> didTimeout</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// order code...</span>

    <span class="token comment">// originalCallbackNode表示当前正在执行的task</span>
    <span class="token comment">// root.callbackNode表示根节点正在调度的task</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>callbackNode <span class="token operator">===</span> originalCallbackNode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果两者相等，说明存在任务中断的情况</span>
        <span class="token comment">// 因为performConcurrentWorkOnRoot执行结束后，root.callbackNode会被重置为null，而originalCallbackNode一定是有值的，那么两者一定不会相等</span>
        <span class="token keyword">return</span> <span class="token function">performConcurrentWorkOnRoot</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>可以看到，在满足一定条件时，该函数会将自己作为返回值。</p> <h2 id="暂停到恢复的完整流程"><a href="#暂停到恢复的完整流程" class="header-anchor">#</a> 暂停到恢复的完整流程</h2> <p>在<code>Concurrent Mode</code>模式下，使用<em>时间切片</em>的特性时，如果当前正在进行中的任务已经没有剩余时间了，则会暂停当前<code>render</code>阶段的<code>performUnitOfWork</code>方法。</p> <p>暂停的过程对应，通过<code>scheduleCallback</code>调度了<code>performConcurrentWorkOnRoot</code>方法。然后通过<code>workLoop</code>方法遍历<code>taskQueue</code>中过期的任务，而这个任务对应的回调函数就是<code>performConcurrentWorkOnRoot</code>方法，所以在这时会执行它。在执行<code>performConcurrentWorkOnRoot</code>方法时，进入到<code>workLoopConcurrent</code>方法中，在<code>while</code>循环中会调用<code>performUnitOfWork</code>方法递归遍历<code>Fiber</code>树。而当时间片用尽时，<code>shouldYield</code>方法返回<code>true</code>，将停止这个<code>while</code>循环，达到了暂停执行的目的。</p> <p>恢复的过程对应，因为<code>performConcurrentWorkOnRoot</code>方法还没有完成<code>render</code>阶段，则根节点还存在正在执行<code>task</code>，所以<code>performConcurrentWorkOnRoot</code>方法会将自己作为返回值，并重新赋值<code>task</code>的<code>callback</code>属性。而因为<code>callback</code>的执行结果还是一个函数，所以这个<code>task</code>会继续存在于taskQueue中，它所对应的过期时间依然是最短的。等到下一轮事件循环，再次调用<code>workLoop</code>方法遍历<code>taskQueue</code>，取出未完成<code>task</code>并执行回调函数，即上次返回的<code>performConcurrentWorkOnRoot</code>方法。这个方法会接着执行未完成的<code>render</code>阶段，达到了恢复执行的目的。</p> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <p><code>Scheduler</code>主要包含两个功能：<strong>时间切片</strong>和<strong>优先级调度</strong>。</p> <p><strong>时间切片</strong>的本质是模拟实现<code>requestIdleCallback</code>，目的是防止<em>阻塞浏览器的渲染</em>，所以需要通过<code>时间切片</code>来控制任务的执行时长。当没有剩余时间时则会<strong>中断</strong>任务的执行，把剩余的时间留给浏览器渲染。等到下一帧再<strong>恢复</strong>任务的执行，重复此过程，直到完成<code>render</code>阶段。</p> <p><strong>优先级调度</strong>，<code>Scheduler</code>对外暴露了一个<code>runWithPriority</code>方法，这个方法接受一个<em>优先级</em>与<em>回调函数</em>。优先级代表任务<strong>过期时间的长短</strong>。高优先级任务的<em>过期时间短</em>，所以会先执行。低优先级任务的<em>过期时间长</em>，就会后执行。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/react-blog/docs/idea/workProcess.html" class="prev">
        React工作流程
      </a></span> <span class="next"><a href="/react-blog/docs/architecture/reconciler.html">
        Reconciler（协调器）
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/react-blog/assets/js/app.1296abc1.js" defer></script><script src="/react-blog/assets/js/2.2aa2ea89.js" defer></script><script src="/react-blog/assets/js/17.0d48f94a.js" defer></script>
  </body>
</html>
