<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Renderer（渲染器） | React笔记</title>
    <meta name="generator" content="VuePress 1.9.5">
    <link rel="icon" href="/react-blog/logo.svg">
    <meta name="description" content="React">
    
    <link rel="preload" href="/react-blog/assets/css/0.styles.7c9b7da0.css" as="style"><link rel="preload" href="/react-blog/assets/js/app.1296abc1.js" as="script"><link rel="preload" href="/react-blog/assets/js/2.2aa2ea89.js" as="script"><link rel="preload" href="/react-blog/assets/js/16.915d1a33.js" as="script"><link rel="prefetch" href="/react-blog/assets/js/10.eec084d2.js"><link rel="prefetch" href="/react-blog/assets/js/11.90e7ad9c.js"><link rel="prefetch" href="/react-blog/assets/js/12.ec712917.js"><link rel="prefetch" href="/react-blog/assets/js/13.5fd1705f.js"><link rel="prefetch" href="/react-blog/assets/js/14.33d6319e.js"><link rel="prefetch" href="/react-blog/assets/js/15.b49ac970.js"><link rel="prefetch" href="/react-blog/assets/js/17.0d48f94a.js"><link rel="prefetch" href="/react-blog/assets/js/18.162dd664.js"><link rel="prefetch" href="/react-blog/assets/js/19.897cc694.js"><link rel="prefetch" href="/react-blog/assets/js/20.c0d68b54.js"><link rel="prefetch" href="/react-blog/assets/js/21.23f5c8b7.js"><link rel="prefetch" href="/react-blog/assets/js/22.17cddd5f.js"><link rel="prefetch" href="/react-blog/assets/js/23.3e2c069f.js"><link rel="prefetch" href="/react-blog/assets/js/24.16287cbc.js"><link rel="prefetch" href="/react-blog/assets/js/25.c9819b86.js"><link rel="prefetch" href="/react-blog/assets/js/26.03bcf156.js"><link rel="prefetch" href="/react-blog/assets/js/27.2e75196a.js"><link rel="prefetch" href="/react-blog/assets/js/28.71dcfa28.js"><link rel="prefetch" href="/react-blog/assets/js/29.0534c7d4.js"><link rel="prefetch" href="/react-blog/assets/js/3.1f92403b.js"><link rel="prefetch" href="/react-blog/assets/js/30.70a1b1a5.js"><link rel="prefetch" href="/react-blog/assets/js/31.8d8007c6.js"><link rel="prefetch" href="/react-blog/assets/js/32.f55b2b21.js"><link rel="prefetch" href="/react-blog/assets/js/33.dea713d0.js"><link rel="prefetch" href="/react-blog/assets/js/34.16302cd1.js"><link rel="prefetch" href="/react-blog/assets/js/35.58ce8424.js"><link rel="prefetch" href="/react-blog/assets/js/36.21c87dbf.js"><link rel="prefetch" href="/react-blog/assets/js/37.e9ccbb00.js"><link rel="prefetch" href="/react-blog/assets/js/38.eda7b7d3.js"><link rel="prefetch" href="/react-blog/assets/js/39.28c4eb15.js"><link rel="prefetch" href="/react-blog/assets/js/4.ace4b147.js"><link rel="prefetch" href="/react-blog/assets/js/40.13eceae9.js"><link rel="prefetch" href="/react-blog/assets/js/41.e5e3f4ba.js"><link rel="prefetch" href="/react-blog/assets/js/42.1ab022fc.js"><link rel="prefetch" href="/react-blog/assets/js/43.eca03ba8.js"><link rel="prefetch" href="/react-blog/assets/js/44.be104c53.js"><link rel="prefetch" href="/react-blog/assets/js/5.68075c63.js"><link rel="prefetch" href="/react-blog/assets/js/6.01147cc3.js"><link rel="prefetch" href="/react-blog/assets/js/7.630cc1a8.js"><link rel="prefetch" href="/react-blog/assets/js/8.80d0f023.js"><link rel="prefetch" href="/react-blog/assets/js/9.f8d3ba3a.js">
    <link rel="stylesheet" href="/react-blog/assets/css/0.styles.7c9b7da0.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/react-blog/" class="home-link router-link-active"><!----> <span class="site-name">React笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://next-blog.irocen.top" target="_blank" rel="noopener noreferrer" class="nav-link external">
  nextjs笔记
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://github.com/Rocen" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="https://next-blog.irocen.top" target="_blank" rel="noopener noreferrer" class="nav-link external">
  nextjs笔记
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://github.com/Rocen" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><a href="/react-blog/" class="sidebar-heading clickable router-link-active"><span>开始</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/react-blog/docs/start/directory.html" class="sidebar-link">目录</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>理念</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>架构</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/react-blog/docs/architecture/scheduler.html" class="sidebar-link">Scheduler（调度器）</a></li><li><a href="/react-blog/docs/architecture/reconciler.html" class="sidebar-link">Reconciler（协调器）</a></li><li><a href="/react-blog/docs/architecture/renderer.html" aria-current="page" class="active sidebar-link">Renderer（渲染器）</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/react-blog/docs/architecture/renderer.html#renderer-渲染器" class="sidebar-link">Renderer（渲染器）</a></li><li class="sidebar-sub-header"><a href="/react-blog/docs/architecture/renderer.html#before-mutation阶段" class="sidebar-link">before mutation阶段</a></li><li class="sidebar-sub-header"><a href="/react-blog/docs/architecture/renderer.html#mutation阶段" class="sidebar-link">mutation阶段</a></li><li class="sidebar-sub-header"><a href="/react-blog/docs/architecture/renderer.html#layout阶段" class="sidebar-link">layout阶段</a></li><li class="sidebar-sub-header"><a href="/react-blog/docs/architecture/renderer.html#current-fiber树切换" class="sidebar-link">current Fiber树切换</a></li><li class="sidebar-sub-header"><a href="/react-blog/docs/architecture/renderer.html#总结" class="sidebar-link">总结</a></li></ul></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>原理</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>概念</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Hooks</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Concurrent Mode</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>实现</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>发现</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="renderer-渲染器"><a href="#renderer-渲染器" class="header-anchor">#</a> Renderer（渲染器）</h2> <p><code>commit</code>阶段的主要工作（即R<code>enderer</code>的工作流程）分为三部分：</p> <ul><li><code>before mutation</code>阶段（执行DOM操作前）</li> <li><code>mutation</code>阶段（执行DOM操作）</li> <li><code>layout</code>阶段（执行DOM操作后）</li></ul> <p>在<code>before mutation</code>阶段之前和<code>layout</code>阶段之后还有一些额外的工作，比如涉及到<code>useEffect</code>的调度和触发，优先级相关的重置，<code>ref</code>的绑定和解绑。</p> <p><code>commit</code>阶段的三个子阶段都会从<code>rootFiber</code>循环向下遍历子<code>Fiber</code>节点，然后为遍历到的子节点执行对应阶段的方法。</p> <h2 id="before-mutation阶段"><a href="#before-mutation阶段" class="header-anchor">#</a> before mutation阶段</h2> <p><code>before mutation</code>阶段的主函数是<code>commitBeforeMutationEffects</code>。代码如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">commitBeforeMutationEffectsOnFiber</span><span class="token punctuation">(</span><span class="token parameter">finishedWork<span class="token operator">:</span> Fiber</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> current <span class="token operator">=</span> finishedWork<span class="token punctuation">.</span>alternate<span class="token punctuation">;</span>
  <span class="token keyword">const</span> flags <span class="token operator">=</span> finishedWork<span class="token punctuation">.</span>flags<span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>enableCreateEventHandleAPI<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>shouldFireAfterActiveInstanceBlur <span class="token operator">&amp;&amp;</span> focusedInstanceHandle <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// ...focus blur相关</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> Snapshot<span class="token punctuation">)</span> <span class="token operator">!==</span> NoFlags<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>finishedWork<span class="token punctuation">.</span>tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 类组件</span>
        <span class="token keyword">case</span> ClassComponent<span class="token operator">:</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
              <span class="token keyword">const</span> prevProps <span class="token operator">=</span> current<span class="token punctuation">.</span>memoizedProps<span class="token punctuation">;</span>
              <span class="token keyword">const</span> prevState <span class="token operator">=</span> current<span class="token punctuation">.</span>memoizedState<span class="token punctuation">;</span>
              <span class="token keyword">const</span> instance <span class="token operator">=</span> finishedWork<span class="token punctuation">.</span>stateNode<span class="token punctuation">;</span>
              <span class="token comment">// 调用getSnapshotBeforeUpdate生命周期函数</span>
              <span class="token keyword">const</span> snapshot <span class="token operator">=</span> instance<span class="token punctuation">.</span><span class="token function">getSnapshotBeforeUpdate</span><span class="token punctuation">(</span>
                  finishedWork<span class="token punctuation">.</span>elementType <span class="token operator">===</span> finishedWork<span class="token punctuation">.</span>type
                  <span class="token operator">?</span> prevProps
                  <span class="token operator">:</span> <span class="token function">resolveDefaultProps</span><span class="token punctuation">(</span>finishedWork<span class="token punctuation">.</span>type<span class="token punctuation">,</span> prevProps<span class="token punctuation">)</span><span class="token punctuation">,</span>
                  prevState<span class="token punctuation">,</span>
              <span class="token punctuation">)</span><span class="token punctuation">;</span>
              instance<span class="token punctuation">.</span>__reactInternalSnapshotBeforeUpdate <span class="token operator">=</span> snapshot<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>commitBeforeMutationEffects</code>函数主要做了两个工作：</p> <ul><li>处理DOM阶段渲染/删除后的<code>autofocus、blur</code>逻辑</li> <li>调用<code>getSnapShotBeforeUpdate</code>生命周期函数</li></ul> <p>从<code>Reactv16</code>开始，一些<code>componentWillXXX</code>钩子前增加了<code>UNSAFE_</code>前缀。因为这些生命周期函数可能存在多次触发的问题，所以<code>React</code>提供了替代的生命周期函数<code>getSnapShotBeforeUpdate</code>。</p> <p>从代码中可以看到，<code>getSnapShotBeforeUpdate</code>是在<code>commit</code>阶段的<code>before mutation</code>阶段调用的，而由于<code>commit</code>阶段是同步执行的，所以不会遇到多次调用<code>getSnapShotBeforeUpdate</code>的问题。</p> <h2 id="mutation阶段"><a href="#mutation阶段" class="header-anchor">#</a> mutation阶段</h2> <p><code>mutation</code>阶段的主函数是<code>commitMutationEffects</code>。代码如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">commitMutationEffectsOnFiber</span><span class="token punctuation">(</span><span class="token parameter">finishedWork<span class="token operator">:</span> Fiber<span class="token punctuation">,</span> root<span class="token operator">:</span> FiberRoot</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 获取flags</span>
  <span class="token keyword">const</span> flags <span class="token operator">=</span> finishedWork<span class="token punctuation">.</span>flags<span class="token punctuation">;</span>
  <span class="token comment">// 根据ContentReset flags重置文本节点</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> ContentReset<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">commitResetTextContent</span><span class="token punctuation">(</span>finishedWork<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 更新ref</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> Ref<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> current <span class="token operator">=</span> finishedWork<span class="token punctuation">.</span>alternate<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">commitDetachRef</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 根据flags分别处理</span>
  <span class="token comment">// 插入或更新</span>
  <span class="token keyword">const</span> primaryFlags <span class="token operator">=</span> flags <span class="token operator">&amp;</span> <span class="token punctuation">(</span>Placement <span class="token operator">|</span> Update <span class="token operator">|</span> Hydrating<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">switch</span> <span class="token punctuation">(</span>primaryFlags<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 处理插入DOM</span>
    <span class="token keyword">case</span> Placement<span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token function">commitPlacement</span><span class="token punctuation">(</span>finishedWork<span class="token punctuation">)</span><span class="token punctuation">;</span>
      finishedWork<span class="token punctuation">.</span>flags <span class="token operator">&amp;=</span> <span class="token operator">~</span>Placement<span class="token punctuation">;</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 处理插入和更新DOM</span>
    <span class="token keyword">case</span> PlacementAndUpdate<span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token comment">// </span>
      <span class="token function">commitPlacement</span><span class="token punctuation">(</span>finishedWork<span class="token punctuation">)</span><span class="token punctuation">;</span>
      finishedWork<span class="token punctuation">.</span>flags <span class="token operator">&amp;=</span> <span class="token operator">~</span>Placement<span class="token punctuation">;</span>

      <span class="token comment">// Update</span>
      <span class="token keyword">const</span> current <span class="token operator">=</span> finishedWork<span class="token punctuation">.</span>alternate<span class="token punctuation">;</span>
      <span class="token function">commitWork</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> finishedWork<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 处理更新DOM</span>
    <span class="token keyword">case</span> Update<span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> current <span class="token operator">=</span> finishedWork<span class="token punctuation">.</span>alternate<span class="token punctuation">;</span>
      <span class="token function">commitWork</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> finishedWork<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>commitMutationEffects</code>函数主要做了三个工作：</p> <ul><li>根据<code>ContentReset flags</code>重置文本节点</li> <li>更新<code>ref</code></li> <li>根据<code>flags</code>分别做不同的处理（<code>Placement</code> | <code>Update</code>）</li></ul> <p>其中还包括<code>Hydrating</code>作为服务端渲染相关，就不需要关注了。</p> <h3 id="placement"><a href="#placement" class="header-anchor">#</a> Placement</h3> <p>当<code>Fiber.flags</code>包含<code>Placement flags</code>，则意味着该<code>Fiber</code>节点对应的<code>DOM</code>节点需要插入到页面中。<br>
调用的方法为<code>commitPlacement</code>，具体代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">commitPlacement</span><span class="token punctuation">(</span><span class="token parameter">finishedWork<span class="token operator">:</span> Fiber</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>supportsMutation<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 获取当前Fibe节点的父级Fiber节点</span>
  <span class="token keyword">const</span> parentFiber <span class="token operator">=</span> <span class="token function">getHostParentFiber</span><span class="token punctuation">(</span>finishedWork<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 寻找父级Fiber节点对应的DOM节点</span>
  <span class="token keyword">let</span> parent<span class="token punctuation">;</span>
  <span class="token keyword">let</span> isContainer<span class="token punctuation">;</span>
  <span class="token keyword">const</span> parentStateNode <span class="token operator">=</span> parentFiber<span class="token punctuation">.</span>stateNode<span class="token punctuation">;</span>
  <span class="token comment">// 根据父级fiber的tag找到对应的DOM节点</span>
  <span class="token keyword">switch</span> <span class="token punctuation">(</span>parentFiber<span class="token punctuation">.</span>tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 原生类型，如div，span</span>
    <span class="token keyword">case</span> HostComponent<span class="token operator">:</span>
      <span class="token comment">// fiber.stateNode就是Fiber节点对应的DOM节点</span>
      parent <span class="token operator">=</span> parentStateNode<span class="token punctuation">;</span>
      isContainer <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token comment">// rootFiber节点，对应根节点</span>
    <span class="token keyword">case</span> HostRoot<span class="token operator">:</span>
      <span class="token comment">// 因为rootFiber节点的stateNode属性指向FiberRootNode</span>
      <span class="token comment">// 所以rootFiber节点的真实DOM节点就保存在FiberRootNode的containerInfo属性上</span>
      parent <span class="token operator">=</span> parentStateNode<span class="token punctuation">.</span>containerInfo<span class="token punctuation">;</span>
      isContainer <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> HostPortal<span class="token operator">:</span>
      <span class="token comment">// 当调用createPortal方法创建的节点</span>
      <span class="token comment">// 传入的第二个参数会作为containerInfo的值</span>
      parent <span class="token operator">=</span> parentStateNode<span class="token punctuation">.</span>containerInfo<span class="token punctuation">;</span>
      isContainer <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token keyword">default</span><span class="token operator">:</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 当该节点包含ContentReset flags，则重置该文本节点</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>parentFiber<span class="token punctuation">.</span>flags <span class="token operator">&amp;</span> ContentReset<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">resetTextContent</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
    parentFiber<span class="token punctuation">.</span>flags <span class="token operator">&amp;=</span> <span class="token operator">~</span>ContentReset<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 获取当前Fiber节点的兄弟节点</span>
  <span class="token keyword">const</span> before <span class="token operator">=</span> <span class="token function">getHostSibling</span><span class="token punctuation">(</span>finishedWork<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>isContainer<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 对应HostRoot和HostPortal的情况</span>
    <span class="token comment">// 该方法与insertOrAppendPlacementNode的唯一区别是：该方法会额外判断容器节点类型是否是COMMENT_NODE</span>
    <span class="token function">insertOrAppendPlacementNodeIntoContainer</span><span class="token punctuation">(</span>finishedWork<span class="token punctuation">,</span> before<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 对应HostComponent的情况</span>
    <span class="token function">insertOrAppendPlacementNode</span><span class="token punctuation">(</span>finishedWork<span class="token punctuation">,</span> before<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// insertOrAppendPlacementNode和insertOrAppendPlacementNodeIntoContainer的代码几乎一致</span>
<span class="token keyword">function</span> <span class="token function">insertOrAppendPlacementNode</span><span class="token punctuation">(</span>
  <span class="token parameter">node<span class="token operator">:</span> Fiber<span class="token punctuation">,</span>
  before<span class="token operator">:</span> <span class="token operator">?</span>Instance<span class="token punctuation">,</span>
  parent<span class="token operator">:</span> Instance<span class="token punctuation">,</span></span>
<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">{</span>tag<span class="token punctuation">}</span> <span class="token operator">=</span> node<span class="token punctuation">;</span>
  <span class="token comment">// 只有原生类型的节点才存在真实DOM节点</span>
  <span class="token keyword">const</span> isHost <span class="token operator">=</span> tag <span class="token operator">===</span> HostComponent <span class="token operator">||</span> tag <span class="token operator">===</span> HostText<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>isHost<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> stateNode <span class="token operator">=</span> node<span class="token punctuation">.</span>stateNode<span class="token punctuation">;</span>
    <span class="token comment">// 判断是否存在兄弟Fiber节点</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>before<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 存在兄弟Fiber节点，需要调用兄弟DOM节点的insertBefore方法执行插入操作</span>
      <span class="token function">insertBefore</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> stateNode<span class="token punctuation">,</span> before<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// 如果不存在兄弟Fiber节点，则调用父级DOM节点的appendChild方法执行插入操作</span>
      <span class="token function">appendChild</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> stateNode<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>tag <span class="token operator">===</span> HostPortal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> child <span class="token operator">=</span> node<span class="token punctuation">.</span>child<span class="token punctuation">;</span>
    <span class="token comment">// 遍历子孙Fiber节点执行插入操作</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>child <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">insertOrAppendPlacementNode</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> before<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">let</span> sibling <span class="token operator">=</span> child<span class="token punctuation">.</span>sibling<span class="token punctuation">;</span>
      <span class="token keyword">while</span> <span class="token punctuation">(</span>sibling <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">insertOrAppendPlacementNode</span><span class="token punctuation">(</span>sibling<span class="token punctuation">,</span> before<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
        sibling <span class="token operator">=</span> sibling<span class="token punctuation">.</span>sibling<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>从这段代码可以看出，<code>commitPlacement</code>方法关键的一步在于需要通过当前<code>Fiber</code>节点是否存在兄弟<code>Fiber</code>节点来决定当前<code>Fiber</code>节点对应<code>DOM</code>节点的插入方式。</p> <p>看到这里可能会有疑问，为什么不默认使用<code>appendChild</code>方法来实现插入操作，还要分情况使用<code>insertBefore</code>方法呢？<br>
原因在于<code>React Diff</code>算法对于更新前后移动的<code>Fiber</code>节点的处理。比如：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 更新前</span>
abcdef

<span class="token comment">// 更新后</span>
abecdf
</code></pre></div><p>同级存在以上5个<code>Fiber</code>节点，字母代表每个<code>Fiber</code>节点的<code>key</code>和<code>DOM</code>节点的文本值。</p> <p>可以看到在更新前后<em>c</em>节点和<em>d</em>节点进行了位置的移动，都移到了<em>e</em>节点的后面，<em>f</em>节点的前面。那么通过<code>diff</code>算法，会将<em>c</em>节点和<em>d</em>节点标记移动，这个标记指为<code>Fiber</code>节点标记<code>Placement flags</code>，就说明需要对<em>c</em>节点和<em>d</em>节点执行插入操作。如果只存在<code>appendChild</code>方法，通过<em>c</em>节点和<em>d</em>节点寻找到它们的父级节点，然后调用父级节点的<code>appendChild</code>方法，完成插入操作的顺序就变成了<em>abefcd</em>，显然结果是不正确的，混乱了节点移动后的顺序。</p> <p>相反，如果使用<code>insertBefore</code>方法就可以在大多数情况下避免顺序的错误。使用<code>insertBefore</code>方法需要寻找当前<code>Fiber</code>节点的下一个兄弟<code>Fiber</code>节点，<em>c</em>节点的兄弟节点是<em>d</em>，d节点的兄弟节点是<em>f</em>。那么通过<code>insertBefore</code>方法，<em>c</em>节点插入到<em>d</em>节点的前面，再将<em>d</em>节点插入到<em>f</em>节点的前面，最终节点的顺序就是正确的了。</p> <p>具体<code>diff</code>算法的介绍可以看<a href="/react-blog/docs/implement/diff.html">这篇</a>文章。</p> <h3 id="update"><a href="#update" class="header-anchor">#</a> Update</h3> <p>当<code>Fiber</code>节点含有<code>Update flags</code>，意味着该<code>Fiber</code>节点需要更新。调用的方法是<code>commitWork</code>，它会根据<code>Fiber.tag</code>分别处理。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 简化后</span>
<span class="token keyword">function</span> <span class="token function">commitWork</span><span class="token punctuation">(</span><span class="token parameter">current<span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span> finishedWork<span class="token operator">:</span> Fiber</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
  <span class="token comment">// 根基Fiber节点的类型</span>
  <span class="token keyword">switch</span> <span class="token punctuation">(</span>finishedWork<span class="token punctuation">.</span>tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 函数组件</span>
    <span class="token keyword">case</span> FunctionComponent<span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token comment">// 执行useLayoutEffect的销毁函数</span>
        <span class="token function">commitHookEffectListUnmount</span><span class="token punctuation">(</span>
          HookLayout <span class="token operator">|</span> HookHasEffect<span class="token punctuation">,</span>
          finishedWork<span class="token punctuation">,</span>
          finishedWork<span class="token punctuation">.</span>return<span class="token punctuation">,</span>
        <span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 类组件</span>
    <span class="token keyword">case</span> ClassComponent<span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 原生节点</span>
    <span class="token keyword">case</span> HostComponent<span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> instance<span class="token operator">:</span> Instance <span class="token operator">=</span> finishedWork<span class="token punctuation">.</span>stateNode<span class="token punctuation">;</span>
      <span class="token comment">// 当前Fiber节点存在真实DOM节点</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> newProps <span class="token operator">=</span> finishedWork<span class="token punctuation">.</span>memoizedProps<span class="token punctuation">;</span>
        <span class="token keyword">const</span> oldProps <span class="token operator">=</span> current <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">?</span> current<span class="token punctuation">.</span>memoizedProps <span class="token operator">:</span> newProps<span class="token punctuation">;</span>
        <span class="token keyword">const</span> type <span class="token operator">=</span> finishedWork<span class="token punctuation">.</span>type<span class="token punctuation">;</span>
        <span class="token comment">// 当updatePayload存在，则说明有需要更新的属性</span>
        <span class="token keyword">const</span> updatePayload<span class="token operator">:</span> <span class="token keyword">null</span> <span class="token operator">|</span> UpdatePayload <span class="token operator">=</span> <span class="token punctuation">(</span>finishedWork<span class="token punctuation">.</span>updateQueue<span class="token operator">:</span> any<span class="token punctuation">)</span><span class="token punctuation">;</span>
        finishedWork<span class="token punctuation">.</span>updateQueue <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>updatePayload <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">// 调用commitUpdate方法进行DOM节点属性的更新</span>
          <span class="token function">commitUpdate</span><span class="token punctuation">(</span>
            instance<span class="token punctuation">,</span>
            updatePayload<span class="token punctuation">,</span>
            type<span class="token punctuation">,</span>
            oldProps<span class="token punctuation">,</span>
            newProps<span class="token punctuation">,</span>
            finishedWork<span class="token punctuation">,</span>
          <span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 文本节点</span>
    <span class="token keyword">case</span> HostText<span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> textInstance<span class="token operator">:</span> TextInstance <span class="token operator">=</span> finishedWork<span class="token punctuation">.</span>stateNode<span class="token punctuation">;</span>
      <span class="token keyword">const</span> newText<span class="token operator">:</span> string <span class="token operator">=</span> finishedWork<span class="token punctuation">.</span>memoizedProps<span class="token punctuation">;</span>
      <span class="token keyword">const</span> oldText<span class="token operator">:</span> string <span class="token operator">=</span>
        current <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">?</span> current<span class="token punctuation">.</span>memoizedProps <span class="token operator">:</span> newText<span class="token punctuation">;</span>
      <span class="token comment">// 更新文本内容</span>
      <span class="token function">commitTextUpdate</span><span class="token punctuation">(</span>textInstance<span class="token punctuation">,</span> oldText<span class="token punctuation">,</span> newText<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>从这段代码可以看到，当前<code>Fiber</code>节点为<code>FunctionComponent</code>时会同步调用<code>useLayoutEffect</code>的销毁函数，入口函数就是<code>commitHookEffectListUnmount</code>。该方法会遍历当前<code>Fiber</code>节点的<code>updateQueue</code>，从第一个<code>effect</code>循环依次执行对应的<code>destory</code>销毁函数。具体的介绍可以看<a href="/react-blog/docs/hooks/executeUseEffect.html#执行useeffect">这篇</a>文章。</p> <p>当前<code>Fiber</code>节点为<code>HostComponent</code>时会进入<code>commitUpdate</code>函数，最终调用<code>updateDOMProperties</code>方法，将<code>render</code>阶段 <code>completeWork</code>中为<code>Fiber</code>节点赋值的<code>updateQueue</code>对应的内容渲染到页面上。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">updateDOMProperties</span><span class="token punctuation">(</span>
  <span class="token parameter">domElement<span class="token operator">:</span> Element<span class="token punctuation">,</span>
  updatePayload<span class="token operator">:</span> Array<span class="token operator">&lt;</span>any<span class="token operator">&gt;</span><span class="token punctuation">,</span>
  wasCustomComponentTag<span class="token operator">:</span> boolean<span class="token punctuation">,</span>
  isCustomComponentTag<span class="token operator">:</span> boolean<span class="token punctuation">,</span></span>
<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
  <span class="token comment">// 循环updatePayload，updatePayload就是updateQueue</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> updatePayload<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// updatePayload是一个数组，偶数项是属性名，奇数项是属性值</span>
    <span class="token comment">// 属性名</span>
    <span class="token keyword">const</span> propKey <span class="token operator">=</span> updatePayload<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">// 属性值</span>
    <span class="token keyword">const</span> propValue <span class="token operator">=</span> updatePayload<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>propKey <span class="token operator">===</span> <span class="token constant">STYLE</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 属性名为style，处理style的值</span>
      <span class="token comment">// 主要工作 首先获取到DOM节点的styles属性，然后for in循环遍历propValue对象，通过 style[styleName] = styleValue 完成属性的设置</span>
      <span class="token function">setValueForStyles</span><span class="token punctuation">(</span>domElement<span class="token punctuation">,</span> propValue<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>propKey <span class="token operator">===</span> <span class="token constant">DANGEROUSLY_SET_INNER_HTML</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 属性名为dangerously_set_inner_html，处理__html的值</span>
      <span class="token comment">// 主要工作 node.innerHTHML = propValue</span>
      <span class="token function">setInnerHTML</span><span class="token punctuation">(</span>domElement<span class="token punctuation">,</span> propValue<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>propKey <span class="token operator">===</span> <span class="token constant">CHILDREN</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 属性名为childrene，处理文本内容</span>
      <span class="token comment">// 主要工作 首先判断是否是单一的文本节点，如果是单一的文本节点，则通过node.nodeValue = text，否则node.textContent = text</span>
      <span class="token function">setTextContent</span><span class="token punctuation">(</span>domElement<span class="token punctuation">,</span> propValue<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// 其他属性</span>
      <span class="token comment">// 会调用setAttribute方法进行预设属性的设置</span>
      <span class="token function">setValueForProperty</span><span class="token punctuation">(</span>domElement<span class="token punctuation">,</span> propKey<span class="token punctuation">,</span> propValue<span class="token punctuation">,</span> isCustomComponentTag<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="deletion"><a href="#deletion" class="header-anchor">#</a> Deletion</h3> <p>在稍早一些版本中，也会通过<code>commitMutationEffectsOnFiber</code>方法对于<code>Fiber</code>节点的<code>effectTag</code>进行判断，是否包含<code>Deletion flags</code>，如果包含的话表示需要将该<code>Fiber</code>节点对应的<code>DOM</code>节点从页面中删除，调用的方法为<code>commitDeletion</code>。</p> <p>但是在17版本中，对于删除节点的逻辑做了调整。通过<code>diff</code>算法计算得出需要删除的节点会调用<code>deleteChild</code>或<code>deleteRemainningChild</code>方法，将需要删除的<code>Fiber</code>节点保存在该父级<code>Fiber</code>节点的<code>deletions</code>属性中，这个属性的数据结构是一个数组。并同时为该父级<code>Fiber</code>节点执行按位或 <code>returnFiber.flags |= ChildDeletion</code> ，表示该<code>Fiber</code>节点存在需要删除的子<code>Fiber</code>节点。</p> <p>具体执行删除的操作是在<code>commitMutationEffectsOnFiber</code>函数的上层函数<code>commitMutationEffects_begin</code>中进行。具体代码如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">commitMutationEffects_begin</span><span class="token punctuation">(</span><span class="token parameter">root<span class="token operator">:</span> FiberRoot</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>nextEffect <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> fiber <span class="token operator">=</span> nextEffect<span class="token punctuation">;</span>

    <span class="token keyword">const</span> deletions <span class="token operator">=</span> fiber<span class="token punctuation">.</span>deletions<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>deletions <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 遍历deletions数组，取到需要删除的Fiber节点，然后调用commitDeletion方法</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> deletions<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> childToDelete <span class="token operator">=</span> deletions<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
          <span class="token function">commitDeletion</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> childToDelete<span class="token punctuation">,</span> fiber<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token function">reportUncaughtErrorInDEV</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token function">captureCommitPhaseError</span><span class="token punctuation">(</span>childToDelete<span class="token punctuation">,</span> fiber<span class="token punctuation">,</span> error<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// .order code...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>commitDeletion</code>方法会执行如下操作：</p> <ul><li>递归遍历<code>Fiber</code>节点及其子孙<code>Fiber</code>节点，调用父级<code>DOM</code>节点的<code>removeChild</code>方法执行删除子DOM节点的操作</li> <li>当<code>fiber.tag</code>为<code>ClassComponent</code>时，会调用存在的<code>componentWillUnmount</code>生命周期函数</li> <li>解绑<code>ref</code>，就是将<code>ref</code>对象或函数置为<code>null</code></li> <li>执行存在的<code>useLayoutEffect</code>的销毁函数</li></ul> <h2 id="layout阶段"><a href="#layout阶段" class="header-anchor">#</a> layout阶段</h2> <p><code>layout</code>阶段主函数是<code>commitLayoutEffects</code>，具体代码如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 简化后</span>
<span class="token keyword">function</span> <span class="token function">commitLayoutEffectOnFiber</span><span class="token punctuation">(</span>
  <span class="token parameter">finishedRoot<span class="token operator">:</span> FiberRoot<span class="token punctuation">,</span>
  current<span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  finishedWork<span class="token operator">:</span> Fiber<span class="token punctuation">,</span>
  committedLanes<span class="token operator">:</span> Lanes<span class="token punctuation">,</span></span>
<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>finishedWork<span class="token punctuation">.</span>flags <span class="token operator">&amp;</span> LayoutMask<span class="token punctuation">)</span> <span class="token operator">!==</span> NoFlags<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>finishedWork<span class="token punctuation">.</span>tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 函数组件</span>
      <span class="token keyword">case</span> FunctionComponent<span class="token operator">:</span><span class="token punctuation">{</span>
        <span class="token comment">// 执行useLayoutEffect的回调函数</span>
        <span class="token function">commitHookEffectListMount</span><span class="token punctuation">(</span>HookLayout <span class="token operator">|</span> HookHasEffect<span class="token punctuation">,</span> finishedWork<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// 类组件</span>
      <span class="token keyword">case</span> ClassComponent<span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> instance <span class="token operator">=</span> finishedWork<span class="token punctuation">.</span>stateNode<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>finishedWork<span class="token punctuation">.</span>flags <span class="token operator">&amp;</span> Update<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>offscreenSubtreeWasHidden<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// current为null时，说明此次是首屏渲染，即mount，调用componentDidMount生命周期函数</span>
                instance<span class="token punctuation">.</span><span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
              <span class="token keyword">const</span> prevProps <span class="token operator">=</span>
                finishedWork<span class="token punctuation">.</span>elementType <span class="token operator">===</span> finishedWork<span class="token punctuation">.</span>type
                  <span class="token operator">?</span> current<span class="token punctuation">.</span>memoizedProps
                  <span class="token operator">:</span> <span class="token function">resolveDefaultProps</span><span class="token punctuation">(</span>
                      finishedWork<span class="token punctuation">.</span>type<span class="token punctuation">,</span>
                      current<span class="token punctuation">.</span>memoizedProps<span class="token punctuation">,</span>
                    <span class="token punctuation">)</span><span class="token punctuation">;</span>
              <span class="token keyword">const</span> prevState <span class="token operator">=</span> current<span class="token punctuation">.</span>memoizedState<span class="token punctuation">;</span>
              <span class="token comment">// current不为null，说明此次不是首屏渲染，即update，调用componentDidUpdate生命周期函数</span>
              instance<span class="token punctuation">.</span><span class="token function">componentDidUpdate</span><span class="token punctuation">(</span>
                prevProps<span class="token punctuation">,</span>
                prevState<span class="token punctuation">,</span>
                instance<span class="token punctuation">.</span>__reactInternalSnapshotBeforeUpdate<span class="token punctuation">,</span>
              <span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">const</span> updateQueue<span class="token operator">:</span> UpdateQueue<span class="token operator">&lt;</span>
          <span class="token operator">*</span><span class="token punctuation">,</span>
        <span class="token operator">&gt;</span> <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">=</span> <span class="token punctuation">(</span>finishedWork<span class="token punctuation">.</span>updateQueue<span class="token operator">:</span> any<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 如果存在updateQueue，说明存在副作用</span>
        <span class="token comment">// 遍历updateQueue.effects，执行effect.callback函数</span>
        <span class="token comment">// 通常指this.setState的第二个参数回调函数</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>updateQueue <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token function">commitUpdateQueue</span><span class="token punctuation">(</span>finishedWork<span class="token punctuation">,</span> updateQueue<span class="token punctuation">,</span> instance<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">case</span> HostRoot<span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> updateQueue<span class="token operator">:</span> UpdateQueue<span class="token operator">&lt;</span>
          <span class="token operator">*</span><span class="token punctuation">,</span>
        <span class="token operator">&gt;</span> <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">=</span> <span class="token punctuation">(</span>finishedWork<span class="token punctuation">.</span>updateQueue<span class="token operator">:</span> any<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>updateQueue <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">let</span> instance <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span>finishedWork<span class="token punctuation">.</span>child <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">switch</span> <span class="token punctuation">(</span>finishedWork<span class="token punctuation">.</span>child<span class="token punctuation">.</span>tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
              <span class="token keyword">case</span> HostComponent<span class="token operator">:</span>
                instance <span class="token operator">=</span> <span class="token function">getPublicInstance</span><span class="token punctuation">(</span>finishedWork<span class="token punctuation">.</span>child<span class="token punctuation">.</span>stateNode<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
              <span class="token keyword">case</span> ClassComponent<span class="token operator">:</span>
                instance <span class="token operator">=</span> finishedWork<span class="token punctuation">.</span>child<span class="token punctuation">.</span>stateNode<span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
          <span class="token punctuation">}</span>
          <span class="token comment">// 与类组件执行副作用的情况一样</span>
          <span class="token comment">// 遍历updateQueue.effects，执行effect.callback函数</span>
          <span class="token comment">// 通常指this.setState的第二个参数回调函数，ReactDOM.render的第三个参数回调函数</span>
          <span class="token function">commitUpdateQueue</span><span class="token punctuation">(</span>finishedWork<span class="token punctuation">,</span> updateQueue<span class="token punctuation">,</span> instance<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">case</span> HostComponent<span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> instance<span class="token operator">:</span> Instance <span class="token operator">=</span> finishedWork<span class="token punctuation">.</span>stateNode<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> finishedWork<span class="token punctuation">.</span>flags <span class="token operator">&amp;</span> Update<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">const</span> type <span class="token operator">=</span> finishedWork<span class="token punctuation">.</span>type<span class="token punctuation">;</span>
          <span class="token keyword">const</span> props <span class="token operator">=</span> finishedWork<span class="token punctuation">.</span>memoizedProps<span class="token punctuation">;</span>
          <span class="token comment">// 用来处理输入框等渲染后的autofocus</span>
          <span class="token function">commitMount</span><span class="token punctuation">(</span>instance<span class="token punctuation">,</span> type<span class="token punctuation">,</span> props<span class="token punctuation">,</span> finishedWork<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>finishedWork<span class="token punctuation">.</span>flags <span class="token operator">&amp;</span> Ref<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 赋值ref</span>
    <span class="token comment">// 主要工作就是获取到该Fiber节点对应的真实DOM节点</span>
    <span class="token comment">// ref如果是对象类型，则赋值给current属性，如果是函数类型，则作为参数传递</span>
    <span class="token function">commitAttachRef</span><span class="token punctuation">(</span>finishedWork<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>commitLayoutEffects</code>函数主要做了三个工作：</p> <ul><li>根据<code>fiber.tag</code>分别处理，当<code>FunctionComponent</code>时，调用<code>useLayoutEffect</code>的回调函数，当<code>ClassComponent</code>时，判断<code>current</code>是否为<code>null</code>，<code>mount</code>时调用<code>componentDidMount</code>，<code>update</code>时调用<code>componentDidUpdate</code></li> <li>执行回调函数，当<code>ClassComponent</code>时，执行<code>this.setState</code>的第二个参数，当<code>HostRoot</code>时，执行<code>ReactDOM.render</code>的第三个参数。</li> <li>赋值<code>ref</code></li></ul> <h2 id="current-fiber树切换"><a href="#current-fiber树切换" class="header-anchor">#</a> current Fiber树切换</h2> <p>从上文可以看到，<code>Renderer</code>阶段的主要工作就是针对<code>Fiber</code>节点对应的<code>DOM</code>节点的执行具体的操作。</p> <p>但在<code>commitRootImpl</code>函数内执行完<code>commitLayoutEffects</code>方法之后，还有两个非常关键的步骤：</p> <ul><li>调度<code>useEffect</code></li> <li>切换<code>currentFiber</code>树</li></ul> <p>因为调度<code>useEffect</code>的内容比较多，同时逻辑比较复杂，会在<a href="/react-blog/docs/hooks/executeUseEffect.html#调度useeffect">这篇</a>文章详细介绍。</p> <p>切换<code>currenFiber</code>树的代码如下：</p> <div class="language-js extra-class"><pre class="language-js"><code>root<span class="token punctuation">.</span>current <span class="token operator">=</span> finishedWork<span class="token punctuation">;</span>
</code></pre></div><p>其实就一行代码。在双缓存机制一节介绍过<code>workInProgress Fiber</code>树在<code>commit</code>阶段完成渲染后会变为<code>current Fiber</code>树。这行代码的作用就是切换<code>fiberRootNode</code>指向的<code>current Fiber</code>树。</p> <p>那么这行代码为什么在这里呢？（在<code>mutation</code>阶段结束后，<code>layout</code>阶段开始前。）</p> <p>我们知道<code>componentWillUnmount</code>会在<code>mutation</code>阶段执行。此时<code>current Fiber</code>树还指向前一次更新的<code>Fiber</code>树，在生命周期钩子内获取的DOM还是更新前的。</p> <p>而<code>componentDidMount</code>或<code>componentDidUpdate</code>会在<code>layout</code>阶段执行。此时<code>current Fiber</code>树已经指向更新后的<code>Fiber</code>树，在生命周期钩子内获取的DOM就是更新后的。</p> <p>所以，在此时进行<code>current Fiber</code>树的切换比较合适。</p> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <p><code>commit</code>阶段的主要工作（即<code>Renderer</code>的工作流程）分为三部分：</p> <ul><li><code>before mutation</code>阶段（执行DOM操作前）</li> <li><code>mutation</code>阶段（执行DOM操作）</li> <li><code>layout</code>阶段（执行DOM操作后）</li></ul> <p><code>before mutation</code>阶段主要做了两个工作：</p> <ul><li>处理DOM阶段渲染/删除后<code>的autofocus、blur</code>逻辑</li> <li>对于<code>ClassComponent</code>，调用<code>getSnapShotBeforeUpdate</code>生命周期函数</li></ul> <p><code>mutation</code>阶段主要做了三个工作：</p> <ul><li>根据<code>ContentReset flags</code>重置文本节点</li> <li>更新<code>ref</code></li> <li>根据<code>flags</code>分别做不同的处理，包括：执行<code>DOM</code>节点的插入，更新<code>DOM</code>节点的属性，删除<code>DOM</code>节点</li></ul> <p><code>layout</code>阶段主要做了三个工作：</p> <ul><li>根据<code>fiber.tag</code>分别做不同的处理，对于<code>FunctionComponent</code>，调用<code>useLayoutEffect</code>的回调函数，对于<code>ClassComponent</code>，判断<code>current</code>是否为<code>null</code>，<code>mount</code>时调用<code>componentDidMount</code>，<code>update</code>时调用<code>componentDidUpdate</code></li> <li>执行回调函数，对于<code>ClassComponent</code>，执行<code>this.setState</code>的第二个参数回调函数，对于<code>HostRoot</code>，执行<code>ReactDOM.render</code>的第三个参数回调函数</li> <li>赋值<code>ref</code></li></ul> <p>在<code>before mutation</code>阶段之前会调度<code>useEffect</code>，<code>layout</code>阶段之后还涉及<code>useEffect</code>的触发和<code>currentFiber</code>树的切换等工作。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/react-blog/docs/architecture/reconciler.html" class="prev">
        Reconciler（协调器）
      </a></span> <span class="next"><a href="/react-blog/docs/principle/diff.html">
        diff算法
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/react-blog/assets/js/app.1296abc1.js" defer></script><script src="/react-blog/assets/js/2.2aa2ea89.js" defer></script><script src="/react-blog/assets/js/16.915d1a33.js" defer></script>
  </body>
</html>
