<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>React中的性能优化 | React笔记</title>
    <meta name="generator" content="VuePress 1.9.5">
    <link rel="icon" href="/react-blog/logo.svg">
    <meta name="description" content="React">
    
    <link rel="preload" href="/react-blog/assets/css/0.styles.7c9b7da0.css" as="style"><link rel="preload" href="/react-blog/assets/js/app.1296abc1.js" as="script"><link rel="preload" href="/react-blog/assets/js/2.2aa2ea89.js" as="script"><link rel="preload" href="/react-blog/assets/js/29.0534c7d4.js" as="script"><link rel="prefetch" href="/react-blog/assets/js/10.eec084d2.js"><link rel="prefetch" href="/react-blog/assets/js/11.90e7ad9c.js"><link rel="prefetch" href="/react-blog/assets/js/12.ec712917.js"><link rel="prefetch" href="/react-blog/assets/js/13.5fd1705f.js"><link rel="prefetch" href="/react-blog/assets/js/14.33d6319e.js"><link rel="prefetch" href="/react-blog/assets/js/15.b49ac970.js"><link rel="prefetch" href="/react-blog/assets/js/16.915d1a33.js"><link rel="prefetch" href="/react-blog/assets/js/17.0d48f94a.js"><link rel="prefetch" href="/react-blog/assets/js/18.162dd664.js"><link rel="prefetch" href="/react-blog/assets/js/19.897cc694.js"><link rel="prefetch" href="/react-blog/assets/js/20.c0d68b54.js"><link rel="prefetch" href="/react-blog/assets/js/21.23f5c8b7.js"><link rel="prefetch" href="/react-blog/assets/js/22.17cddd5f.js"><link rel="prefetch" href="/react-blog/assets/js/23.3e2c069f.js"><link rel="prefetch" href="/react-blog/assets/js/24.16287cbc.js"><link rel="prefetch" href="/react-blog/assets/js/25.c9819b86.js"><link rel="prefetch" href="/react-blog/assets/js/26.03bcf156.js"><link rel="prefetch" href="/react-blog/assets/js/27.2e75196a.js"><link rel="prefetch" href="/react-blog/assets/js/28.71dcfa28.js"><link rel="prefetch" href="/react-blog/assets/js/3.1f92403b.js"><link rel="prefetch" href="/react-blog/assets/js/30.70a1b1a5.js"><link rel="prefetch" href="/react-blog/assets/js/31.8d8007c6.js"><link rel="prefetch" href="/react-blog/assets/js/32.f55b2b21.js"><link rel="prefetch" href="/react-blog/assets/js/33.dea713d0.js"><link rel="prefetch" href="/react-blog/assets/js/34.16302cd1.js"><link rel="prefetch" href="/react-blog/assets/js/35.58ce8424.js"><link rel="prefetch" href="/react-blog/assets/js/36.21c87dbf.js"><link rel="prefetch" href="/react-blog/assets/js/37.e9ccbb00.js"><link rel="prefetch" href="/react-blog/assets/js/38.eda7b7d3.js"><link rel="prefetch" href="/react-blog/assets/js/39.28c4eb15.js"><link rel="prefetch" href="/react-blog/assets/js/4.ace4b147.js"><link rel="prefetch" href="/react-blog/assets/js/40.13eceae9.js"><link rel="prefetch" href="/react-blog/assets/js/41.e5e3f4ba.js"><link rel="prefetch" href="/react-blog/assets/js/42.1ab022fc.js"><link rel="prefetch" href="/react-blog/assets/js/43.eca03ba8.js"><link rel="prefetch" href="/react-blog/assets/js/44.be104c53.js"><link rel="prefetch" href="/react-blog/assets/js/5.68075c63.js"><link rel="prefetch" href="/react-blog/assets/js/6.01147cc3.js"><link rel="prefetch" href="/react-blog/assets/js/7.630cc1a8.js"><link rel="prefetch" href="/react-blog/assets/js/8.80d0f023.js"><link rel="prefetch" href="/react-blog/assets/js/9.f8d3ba3a.js">
    <link rel="stylesheet" href="/react-blog/assets/css/0.styles.7c9b7da0.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/react-blog/" class="home-link router-link-active"><!----> <span class="site-name">React笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://next-blog.irocen.top" target="_blank" rel="noopener noreferrer" class="nav-link external">
  nextjs笔记
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://github.com/Rocen" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="https://next-blog.irocen.top" target="_blank" rel="noopener noreferrer" class="nav-link external">
  nextjs笔记
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://github.com/Rocen" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><a href="/react-blog/" class="sidebar-heading clickable router-link-active"><span>开始</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/react-blog/docs/start/directory.html" class="sidebar-link">目录</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>理念</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>架构</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>原理</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>概念</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Hooks</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Concurrent Mode</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>实现</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>发现</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/react-blog/docs/find/componentRenderAndOptimize.html" class="sidebar-link">组件渲染和性能优化</a></li><li><a href="/react-blog/docs/find/differentBetweenSetStateAndUseState.html" class="sidebar-link">setState和useState的区别</a></li><li><a href="/react-blog/docs/find/isUseStateSyncOrAsync.html" class="sidebar-link">useState是同步还是异步</a></li><li><a href="/react-blog/docs/find/performanceOptimize.html" aria-current="page" class="active sidebar-link">React中的性能优化</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/react-blog/docs/find/performanceOptimize.html#react中的性能优化" class="sidebar-link">React中的性能优化</a></li><li class="sidebar-sub-header"><a href="/react-blog/docs/find/performanceOptimize.html#伴随的问题" class="sidebar-link">伴随的问题</a></li><li class="sidebar-sub-header"><a href="/react-blog/docs/find/performanceOptimize.html#eagerstate的触发条件" class="sidebar-link">eagerState的触发条件</a></li><li class="sidebar-sub-header"><a href="/react-blog/docs/find/performanceOptimize.html#总结" class="sidebar-link">总结</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="react中的性能优化"><a href="#react中的性能优化" class="header-anchor">#</a> React中的性能优化</h2> <p><code>React</code>源码内部有一个名词<code>bailout</code>，指当<code>useState</code>更新的<code>state</code>与当前<code>state</code>一致时（通过<code>Object.is</code>比较），<code>React</code>则不会重新<code>render</code>该组件的子组件，而会复用前一次更新已经生成的<code>Fiber</code>节点。</p> <p><strong>注意</strong>：当命中<code>bailout</code>后，该组件可能还是会<code>render</code>，但是它的子组件并不会重新<code>render</code>。</p> <p>这是因为，大部分情况下，只有当前组件<code>render</code>时，<code>useState</code>才会执行，然后计算出新的<code>state</code>，进而与旧的<code>state</code>比较。这是针对子组件的性能优化手段。</p> <p>React的工作流程可以简单概括为：</p> <ol><li>交互触发的状态更新</li> <li>组件树进行render</li></ol> <p>刚才说的<code>bailout</code>发生在步骤<em>2</em>：组件树开始<code>render</code>后，命中了<code>bailout</code>的逻辑后，子组件并不会进行<code>render</code>。</p> <p>实际上，还有一种更前置的优化策略：当步骤<em>1</em>触发时，发现<code>state</code>并没有发生变化，则直接退出，不会进行后续的工作流程。</p> <p>正常情况下，执行点击事件的同时触发更新，直到<code>render</code>组件，执行<code>useState</code>后计算出新的<code>state</code>，进而与旧的<code>state</code>比较，然后再判断是否命中<code>bailout</code>的逻辑。</p> <p>当执行点击事件时，可以立即计算出新的<code>state</code>，并与旧的<code>state</code>比较，如果两者相等的话，则不会进行组件树的<code>render</code>。</p> <p>这种将计算<code>state</code>的时机提前的策略称为<code>eagerState</code>（急切的<code>state</code>）。</p> <h2 id="伴随的问题"><a href="#伴随的问题" class="header-anchor">#</a> 伴随的问题</h2> <p>通过交互触发的状态更新，如果状态前后的值没有变化，则可以省略剩下的步骤，这个优化策略被称为<code>eagerState</code>。</p> <p>组件<code>render</code>时，如果子孙组件节点没有状态变化，则可以跳过子孙组件的重新<code>render</code>，这个优化策略被称为<code>bailout</code>。</p> <p>从描述上来看，<code>eagerState</code>的逻辑是比较简单，只需要比较更新前后的<code>state</code>是否相等就可以了。</p> <p>但是实现上却很复杂。</p> <h2 id="eagerstate的触发条件"><a href="#eagerstate的触发条件" class="header-anchor">#</a> eagerState的触发条件</h2> <p>什么叫“急切”的状态？只有在组件<code>render</code>的时候才能获取到组件的最新状态，即通过组件<code>render</code>并执行<code>useState</code>，然后计算出新的<code>state</code>。</p> <p>通常交互可能触发多个更新，这些多个更新将<strong>共同</strong>决定新状态的值。同时，这些更新都拥有各自的<em>优先级</em>，所以在<code>render</code>前并不能确定哪些更新会参与到状态的计算中。所以，这种情况必须执行组件的<code>render</code>，<code>useState</code>必须经过执行才能知道新状态的值。</p> <p>而<code>eagerState</code>的意义是在某种情况下，可以将这个计算的时机<strong>提前</strong>，在组件<code>render</code>之前就可以计算出最新的状态。</p> <p>这个情况是什么呢？当<strong>组件上不存更新</strong>时。</p> <p>当组件不存在更新的时候，即本次更新就是该组件的第一个更新。所以在只有一个更新的情况下是可以<strong>提前</strong>确定最新的<code>state</code>。</p> <p>所以<code>eagerState</code>的前提就是：当前组件不存在更新，那么首次触发更新的时候，就可以立即计算出最新<code>state</code>，然后与当前<code>state</code>比较。如果两者的值一致，则省略后续<code>render</code>的流程。</p> <p>例子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>num<span class="token punctuation">,</span> updateNum<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;App render&quot;</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">updateNum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>Child <span class="token operator">/</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;child render&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token operator">&lt;</span>span<span class="token operator">&gt;</span>child<span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>输出的结果：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 挂载时输出</span>
App render <span class="token number">0</span>
child render 

<span class="token comment">// 第一次点击输出</span>
App render <span class="token number">1</span>
child render

<span class="token comment">// 第二次点击输出</span>
App render <span class="token number">1</span>

<span class="token comment">// 第三次点击及之后，什么也不会打印</span>

</code></pre></div><p>第二次点击时，理论上前后<code>state</code>的值并没有变化，所以不应该执行组件的<code>render</code>。但是结果竟然会执行组件的<code>render</code>。</p> <p>存在这种问题的原因是什么呢？</p> <p><code>eagerState</code>的前提是：当前组件不存在更新。但是具体到源码来说，是组件对应的<code>current fiber</code>与<code>workInProgress fiber</code>都不存在更新。</p> <p>当第一次点击<em>div</em>时，打印：</p> <div class="language- extra-class"><pre class="language-text"><code>App render1
child render
</code></pre></div><p>在<code>React</code>的工作流程中，会调用<code>markUpdateLaneFromFiberToRoot</code>方法为<code>current fiber</code>标记更新，即<code>fiber.lanes = 1</code>。</p> <p>然后在<code>beginWork</code>方法中，会先复用<code>current fiber</code>的一些属性（包括<code>lanes</code>）来创建<code>App FC</code>对应的<code>workInProgress fiber</code>，所以创建出来的<code>workInProgress fiber.lanes = 1</code>。</p> <p>然后调用<code>renderWithHooks</code>方法执行组件的渲染。</p> <p>在<code>renderWithHooks</code>方法中，会先清除<code>workInProgress fiber</code>的<code>lanes</code>标记，即<code>workInProgress.lanes = NoLanes</code>，然后再调用<code>updateReducer</code>计算新的<code>state</code>。</p> <p>完成渲染后会进行<code>fiber</code>树的切换，将构建好的<code>workInProgress fiber</code>与<code>current fiber</code>交换位置，即<code>workInProgress fiber</code>树变为<code>current fiber</code>树，<code>current fiber</code>树再变为<code>workInProgress fiber</code>树。</p> <p>至此完成了一次状态更新，但是可以发现：在切换<code>fiber</code>树之前<code>current fiber</code>其实还存在更新标记（<code>lanes = 1</code>），因为在以上状态更新的过程中并没有清除<code>current fiber.lanes</code>的值。</p> <p>所以，尽管<code>React</code>最终进行了<code>fiber</code>树的替换，但是更新后的<code>curren fiber</code>与<code>workInProgress fiber</code>依然会通过<code>alternate</code>属性进行连接。</p> <p>以下是<code>eagerState</code>优化逻辑的代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> dispatchAction<span class="token operator">&lt;</span><span class="token constant">S</span><span class="token punctuation">,</span> <span class="token constant">A</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>
  fiber<span class="token operator">:</span> Fiber<span class="token punctuation">,</span>
  queue<span class="token operator">:</span> UpdateQueue<span class="token operator">&lt;</span><span class="token constant">S</span><span class="token punctuation">,</span> <span class="token constant">A</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
  action<span class="token operator">:</span> <span class="token constant">A</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> alternate <span class="token operator">=</span> fiber<span class="token punctuation">.</span>alternate<span class="token punctuation">;</span>
    <span class="token comment">// ...</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>
      fiber<span class="token punctuation">.</span>lanes <span class="token operator">===</span> NoLanes <span class="token operator">&amp;&amp;</span>
      <span class="token punctuation">(</span>alternate <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span> alternate<span class="token punctuation">.</span>lanes <span class="token operator">===</span> NoLanes<span class="token punctuation">)</span>
    <span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//...</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">is</span><span class="token punctuation">(</span>eagerState<span class="token punctuation">,</span> currentState<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>从这段代码可以看到，进行<code>eagerState</code>逻辑判断的条件是<code>fiber.lanes === 0</code>，并且<code>alternate === null || alternate.lanes === 0</code>。而这个<code>fiber</code>指的是<code>workInProgress fiber</code>。</p> <p>上面我们已经讲过了，在第一次点击触发的状态更新流程中，切换<code>fiber</code>树之前<code>current fiber</code>存在更新，<code>workInProgress fiber</code>不存在更新。</p> <p>在切换<code>fiber</code>树之后，<code>current fiber</code>不存在更新，而<code>workInProgress fiber</code>存在更新。</p> <p>然后在第二次点击调用<code>dispatchAction</code>方法时，这个<code>fiber</code>指的是当前的<code>workInProgress fiber</code>，它是存在存更新的。</p> <p>所以，在进入<code>eagerState</code>条件判断时，虽然满足<code>alternate.lanes === 0</code>，但是不满足<code>fiber.lanes === null</code>，因此没有命中<code>eagerState</code>的优化策略，从而又开启了一次状态更新。</p> <p>通过这次触发的状态更新流程，依然会通过<code>markUpdateLaneFromFiberToRoot</code>为<code>current fiber</code>和<code>workInProgress fiber</code>同时标记更新<code>lanes = 1</code>。</p> <p>但与之前不同的是，这次更新中新旧<code>props</code>没有变化，所以会将更新标志位<code>didReceiveUpdate</code>置为<em>false</em>。</p> <p>接着根据<code>workInProgress.tag</code>等于<code>FunctionComponent</code>而调用<code>updateFunctionComponent</code>方法。在<code>updateFunctionComponent</code>方法内部，会调用<code>renderWithHooks</code>方法执行组件的渲染，然后会进行如下的判断：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>didReceiveUpdate<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">bailoutHooks</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> workInProgress<span class="token punctuation">,</span> renderLanes<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token function">bailoutOnAlreadyFinishedWork</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> workInProgress<span class="token punctuation">,</span> renderLanes<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>因为本次属于<code>update</code>，所以<code>current</code>是存在的。并且<code>didReceiveUpdate</code>已经为<code>false</code>了，可以满足上述判断条件。</p> <p>接着调用<code>bailoutHooks</code>方法：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">bailoutHooks</span><span class="token punctuation">(</span>
  <span class="token parameter">current<span class="token operator">:</span> Fiber<span class="token punctuation">,</span>
  workInProgress<span class="token operator">:</span> Fiber<span class="token punctuation">,</span>
  lanes<span class="token operator">:</span> Lanes<span class="token punctuation">,</span></span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 复用current fiber的updateQueue属性</span>
  workInProgress<span class="token punctuation">.</span>updateQueue <span class="token operator">=</span> current<span class="token punctuation">.</span>updateQueue<span class="token punctuation">;</span>
  <span class="token comment">// 赋值effect</span>
  workInProgress<span class="token punctuation">.</span>flags <span class="token operator">&amp;=</span> <span class="token operator">~</span><span class="token punctuation">(</span>PassiveEffect <span class="token operator">|</span> UpdateEffect<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 移除current fiber.lanes属性中包含的lanes值</span>
  <span class="token comment">// removeLanes = current.lanes &amp; ~lanes</span>
  current<span class="token punctuation">.</span>lanes <span class="token operator">=</span> <span class="token function">removeLanes</span><span class="token punctuation">(</span>current<span class="token punctuation">.</span>lanes<span class="token punctuation">,</span> lanes<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>可以看到在调用了<code>bailoutHooks</code>方法后，会清除掉<code>current fiber.lanes</code>属性上包含的<code>lanes</code>值。因为当前<code>current fiber.lanes = 1</code>，在执行<code>removeLanes</code>方法后，<code>current fiber.lanes = 0</code>。</p> <p>在执行完<code>bailoutHooks</code>方法后，会调用<code>bailoutOnAlreadyFinishedWork</code>方法复用<code>current fiber</code>来创建<code>workInProgress fiber</code>。</p> <p>最后，<code>commit</code>阶段会切换<code>fiber</code>树，<code>current fiber</code>树变为<code>workInProgress fiber</code>树，<code>workInProgress fiber</code>树变为<code>current fiber</code>树。</p> <p>再到第三次点击调用<code>dispatchAction</code>方法时，<code>fiber</code>对应的<code>workInProgress fiber</code>不存在更新。<code>alternate</code>对应的<code>current fiber</code>也不存在更新，所以此次执行会命中<code>eagerState</code>的优化策略，不会开启状态更新，从而达到性能优化的目的。</p> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <p>综上所述，<code>React</code>性能优化并没有做到极致，因为存在两个相关联的<code>fiber</code>节点，并且也没有对<code>current fiber</code>上的更新标记及时的进行清除，导致在<code>fiber</code>树的切换后<code>workInProgress fiber</code>上总是存在更新标记。</p> <p>由此可见，<code>eagerState</code>的优化策略并没有达到<em>最</em>理想的状态。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/react-blog/docs/find/isUseStateSyncOrAsync.html" class="prev">
        useState是同步还是异步
      </a></span> <!----></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/react-blog/assets/js/app.1296abc1.js" defer></script><script src="/react-blog/assets/js/2.2aa2ea89.js" defer></script><script src="/react-blog/assets/js/29.0534c7d4.js" defer></script>
  </body>
</html>
