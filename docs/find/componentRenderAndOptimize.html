<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>组件渲染 | React笔记</title>
    <meta name="generator" content="VuePress 1.9.5">
    <link rel="icon" href="/react-blog/logo.svg">
    <meta name="description" content="React">
    
    <link rel="preload" href="/react-blog/assets/css/0.styles.7c9b7da0.css" as="style"><link rel="preload" href="/react-blog/assets/js/app.1296abc1.js" as="script"><link rel="preload" href="/react-blog/assets/js/2.2aa2ea89.js" as="script"><link rel="preload" href="/react-blog/assets/js/26.03bcf156.js" as="script"><link rel="prefetch" href="/react-blog/assets/js/10.eec084d2.js"><link rel="prefetch" href="/react-blog/assets/js/11.90e7ad9c.js"><link rel="prefetch" href="/react-blog/assets/js/12.ec712917.js"><link rel="prefetch" href="/react-blog/assets/js/13.5fd1705f.js"><link rel="prefetch" href="/react-blog/assets/js/14.33d6319e.js"><link rel="prefetch" href="/react-blog/assets/js/15.b49ac970.js"><link rel="prefetch" href="/react-blog/assets/js/16.915d1a33.js"><link rel="prefetch" href="/react-blog/assets/js/17.0d48f94a.js"><link rel="prefetch" href="/react-blog/assets/js/18.162dd664.js"><link rel="prefetch" href="/react-blog/assets/js/19.897cc694.js"><link rel="prefetch" href="/react-blog/assets/js/20.c0d68b54.js"><link rel="prefetch" href="/react-blog/assets/js/21.23f5c8b7.js"><link rel="prefetch" href="/react-blog/assets/js/22.17cddd5f.js"><link rel="prefetch" href="/react-blog/assets/js/23.3e2c069f.js"><link rel="prefetch" href="/react-blog/assets/js/24.16287cbc.js"><link rel="prefetch" href="/react-blog/assets/js/25.c9819b86.js"><link rel="prefetch" href="/react-blog/assets/js/27.2e75196a.js"><link rel="prefetch" href="/react-blog/assets/js/28.71dcfa28.js"><link rel="prefetch" href="/react-blog/assets/js/29.0534c7d4.js"><link rel="prefetch" href="/react-blog/assets/js/3.1f92403b.js"><link rel="prefetch" href="/react-blog/assets/js/30.70a1b1a5.js"><link rel="prefetch" href="/react-blog/assets/js/31.8d8007c6.js"><link rel="prefetch" href="/react-blog/assets/js/32.f55b2b21.js"><link rel="prefetch" href="/react-blog/assets/js/33.dea713d0.js"><link rel="prefetch" href="/react-blog/assets/js/34.16302cd1.js"><link rel="prefetch" href="/react-blog/assets/js/35.58ce8424.js"><link rel="prefetch" href="/react-blog/assets/js/36.21c87dbf.js"><link rel="prefetch" href="/react-blog/assets/js/37.e9ccbb00.js"><link rel="prefetch" href="/react-blog/assets/js/38.eda7b7d3.js"><link rel="prefetch" href="/react-blog/assets/js/39.28c4eb15.js"><link rel="prefetch" href="/react-blog/assets/js/4.ace4b147.js"><link rel="prefetch" href="/react-blog/assets/js/40.13eceae9.js"><link rel="prefetch" href="/react-blog/assets/js/41.e5e3f4ba.js"><link rel="prefetch" href="/react-blog/assets/js/42.1ab022fc.js"><link rel="prefetch" href="/react-blog/assets/js/43.eca03ba8.js"><link rel="prefetch" href="/react-blog/assets/js/44.be104c53.js"><link rel="prefetch" href="/react-blog/assets/js/5.68075c63.js"><link rel="prefetch" href="/react-blog/assets/js/6.01147cc3.js"><link rel="prefetch" href="/react-blog/assets/js/7.630cc1a8.js"><link rel="prefetch" href="/react-blog/assets/js/8.80d0f023.js"><link rel="prefetch" href="/react-blog/assets/js/9.f8d3ba3a.js">
    <link rel="stylesheet" href="/react-blog/assets/css/0.styles.7c9b7da0.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/react-blog/" class="home-link router-link-active"><!----> <span class="site-name">React笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://next-blog.irocen.top" target="_blank" rel="noopener noreferrer" class="nav-link external">
  nextjs笔记
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://github.com/Rocen" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="https://next-blog.irocen.top" target="_blank" rel="noopener noreferrer" class="nav-link external">
  nextjs笔记
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://github.com/Rocen" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><a href="/react-blog/" class="sidebar-heading clickable router-link-active"><span>开始</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/react-blog/docs/start/directory.html" class="sidebar-link">目录</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>理念</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>架构</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>原理</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>概念</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Hooks</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Concurrent Mode</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>实现</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>发现</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/react-blog/docs/find/componentRenderAndOptimize.html" aria-current="page" class="active sidebar-link">组件渲染和性能优化</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/react-blog/docs/find/componentRenderAndOptimize.html#组件渲染" class="sidebar-link">组件渲染</a></li><li class="sidebar-sub-header"><a href="/react-blog/docs/find/componentRenderAndOptimize.html#代数效应" class="sidebar-link">代数效应</a></li><li class="sidebar-sub-header"><a href="/react-blog/docs/find/componentRenderAndOptimize.html#函数组件的渲染" class="sidebar-link">函数组件的渲染</a></li><li class="sidebar-sub-header"><a href="/react-blog/docs/find/componentRenderAndOptimize.html#类组件的渲染" class="sidebar-link">类组件的渲染</a></li><li class="sidebar-sub-header"><a href="/react-blog/docs/find/componentRenderAndOptimize.html#函数组件性能优化" class="sidebar-link">函数组件性能优化</a></li><li class="sidebar-sub-header"><a href="/react-blog/docs/find/componentRenderAndOptimize.html#类组件性能优化" class="sidebar-link">类组件性能优化</a></li><li class="sidebar-sub-header"><a href="/react-blog/docs/find/componentRenderAndOptimize.html#react-memo" class="sidebar-link">React.memo</a></li></ul></li><li><a href="/react-blog/docs/find/differentBetweenSetStateAndUseState.html" class="sidebar-link">setState和useState的区别</a></li><li><a href="/react-blog/docs/find/isUseStateSyncOrAsync.html" class="sidebar-link">useState是同步还是异步</a></li><li><a href="/react-blog/docs/find/performanceOptimize.html" class="sidebar-link">React中的性能优化</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="组件渲染"><a href="#组件渲染" class="header-anchor">#</a> 组件渲染</h2> <p>在<code>React</code>中主要使用的组件分为<code>ClassComponent</code>和<code>FunctionComponent</code>两种。且在<code>Hooks</code>配合<code>FunctionComponent</code>大量使用之前，<code>FunctionComponent</code>的唯一用途就是UI组件即无状态组件。那么什么是无状态组件呢？</p> <p>无状态组件就是只负责页面的渲染，不做其他复杂逻辑操作的组件就是无状态组件。无状态组件并不是被定义为它应该是无状态的，而是<code>FunctionComponent</code>独特的渲染方式造成了这样的结果。而在这之后，<code>React</code>推出了新的编写组件的方式，就是<code>FunctionComponent</code>和<code>Hooks</code>的组合，并且这种组合践行的理念是<code>代数效应</code>。</p> <h2 id="代数效应"><a href="#代数效应" class="header-anchor">#</a> 代数效应</h2> <p>代数效应是什么？代数效应是函数式编程的一个概念，用于将<em>副作用</em>从函数中分离，使函数关注点保持<strong>存粹</strong>。</p> <p>那么代数效应与<code>React</code>有什么关系呢？最明显的一个例子就是Hooks。</p> <p>在有了<code>useState</code>，<code>useReducer</code>，<code>useRef</code>这样的<code>Hooks</code>，我们就不需要关注在<code>FunctionComponent</code>中如何保存<code>state</code>，这些<code>React</code>会为我们处理。</p> <h2 id="函数组件的渲染"><a href="#函数组件的渲染" class="header-anchor">#</a> 函数组件的渲染</h2> <p>我们说的组件渲染就是执行组件获取<code>JSX</code>语法通过<code>React.createElement</code>返回的<code>React Element</code>。</p> <p>那么函数组件渲染的特点就是函数的执行导致函数内定义的变量和函数都会被<strong>重新声明</strong>和<strong>赋值</strong>，导致无法对这些变量和函数进行有效的操作。</p> <p>所以，为了解决这种问题就需要使用<code>Hooks</code>配合函数组件进行开发了。</p> <p>如代码所示：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> renderWithHooks<span class="token operator">&lt;</span>Props<span class="token punctuation">,</span> SecondArg<span class="token operator">&gt;</span><span class="token punctuation">(</span>
  current<span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  workInProgress<span class="token operator">:</span> Fiber<span class="token punctuation">,</span>
  <span class="token function-variable function">Component</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">p<span class="token operator">:</span> Props<span class="token punctuation">,</span> arg<span class="token operator">:</span> SecondArg</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> any<span class="token punctuation">,</span>
  props<span class="token operator">:</span> Props<span class="token punctuation">,</span>
  secondArg<span class="token operator">:</span> SecondArg<span class="token punctuation">,</span>
  nextRenderLanes<span class="token operator">:</span> Lanes<span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token operator">:</span> any <span class="token punctuation">{</span>
    <span class="token comment">// order code...</span>

    <span class="token keyword">let</span> children <span class="token operator">=</span> <span class="token function">Component</span><span class="token punctuation">(</span>props<span class="token punctuation">,</span> secondArg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// order code...</span>

    <span class="token keyword">return</span> children<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在<code>beginWork</code>中对于<code>FunctionComponent</code>类型的组件最终会调用<code>renderWithHooks</code>方法获取函数组件的执行结果<code>React Element</code>，进而生成对应的<code>Fiber</code>节点。</p> <p>值得注意的是，在<code>renderWithHooks</code>内部并没有其他性能优化的手段来控制组件是否执行渲染。也就是说，从函数组件自身的角度来看，只有<code>useState</code>的返回函数<code>dispatchAction</code>中在<strong>特定情况</strong>下会对<em>旧新state</em>进行<strong>浅比较</strong>。比较结果相等的话，就不会开启调度更新，从而避免不必要的更新。</p> <h2 id="类组件的渲染"><a href="#类组件的渲染" class="header-anchor">#</a> 类组件的渲染</h2> <p>类组件渲染的方式就是调用<code>this.render</code>方法获取返回结果<code>React Element</code>，这过程也伴随着一系列的生命周期函数的执行。</p> <p>如代码所示：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">updateClassInstance</span><span class="token punctuation">(</span>
  <span class="token parameter">current<span class="token operator">:</span> Fiber<span class="token punctuation">,</span>
  workInProgress<span class="token operator">:</span> Fiber<span class="token punctuation">,</span>
  ctor<span class="token operator">:</span> any<span class="token punctuation">,</span>
  newProps<span class="token operator">:</span> any<span class="token punctuation">,</span>
  renderLanes<span class="token operator">:</span> Lanes<span class="token punctuation">,</span></span>
<span class="token punctuation">)</span><span class="token operator">:</span> boolean <span class="token punctuation">{</span>
    <span class="token comment">// order code...</span>

    <span class="token keyword">const</span> shouldUpdate <span class="token operator">=</span> 
        <span class="token function">checkHasForceUpdateAfterProcessing</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token operator">||</span> <span class="token function">checkShouldComponentUpdate</span><span class="token punctuation">(</span>
            workInProgress<span class="token punctuation">,</span>
            ctor<span class="token punctuation">,</span>
            oldProps<span class="token punctuation">,</span>
            newProps<span class="token punctuation">,</span>
            oldState<span class="token punctuation">,</span>
            newState<span class="token punctuation">,</span>
            nextContext<span class="token punctuation">,</span>
        <span class="token punctuation">)</span>
    <span class="token comment">// order code...</span>

    <span class="token keyword">return</span> shouldUpdate<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">finishClassComponent</span><span class="token punctuation">(</span>
  <span class="token parameter">current<span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  workInProgress<span class="token operator">:</span> Fiber<span class="token punctuation">,</span>
  Component<span class="token operator">:</span> any<span class="token punctuation">,</span>
  shouldUpdate<span class="token operator">:</span> boolean<span class="token punctuation">,</span>
  hasContext<span class="token operator">:</span> boolean<span class="token punctuation">,</span>
  renderLanes<span class="token operator">:</span> Lanes<span class="token punctuation">,</span></span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// order code...</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>shouldUpdate <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>didCaptureError<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 直接复用上次的已经存在的Fiber节点</span>
        <span class="token keyword">return</span> <span class="token function">bailoutOnAlreadyFinishedWork</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> workInProgress<span class="token punctuation">,</span> renderLanes<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">const</span> instance <span class="token operator">=</span> workInProgress<span class="token punctuation">.</span>stateNode<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>
        didCaptureError <span class="token operator">&amp;&amp;</span>
        <span class="token keyword">typeof</span> Component<span class="token punctuation">.</span>getDerivedStateFromError <span class="token operator">!==</span> <span class="token string">'function'</span>
    <span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果有错误则进行组件的渲染</span>
        nextChildren <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 重新执行render方法获取React Element</span>
        nextChildren <span class="token operator">=</span> instance<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// order code...</span>

    <span class="token keyword">return</span> nextChildren<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这段代码主要关注<code>updateClassInstance</code>方法中返回的<code>shouldUpdate</code>值，通过调用<code>checkHasForceUpdateAfterProcessing</code>方法或者<code>checkShouldComponentUpdate</code>会计算出是否需要进行组件的更新。</p> <p>其中<code>checkHasForceUpdateAfterProcessing</code>方法是判断当前组件是否使用了<code>this.forceUpdate</code>方法，如果使用强制更新了则返回<em>true</em>，没有使用强制更新则返回<em>false</em>并接着调用<code>checkShouldComponentUpdate</code>方法。</p> <p><code>checkShouldComponentUpdate</code>方法就是判断当前组件是否存在<code>shouldComponentUpdate</code>这个生命周期函数，如果存在则调用这个生命周期函数，拿到<code>shouldComponentUpdate</code>的返回值作为<code>checkShouldComponentUpdate</code>方法的返回值，如果没有<code>shouldComponentUpdate</code>生命周期函数，则默认返回<em>true</em>（<em>true</em>表示需要进行组件渲染，<em>false</em>表示不需要进行组件渲染）。</p> <p><code>updateClassInstance</code>方法的返回值<code>shouldUpdate</code>会作为第四个参数传递给<code>finishClassComponent</code>方法，而<code>shouldUpdate</code>就会作为本次是否执行类组件渲染的<strong>判断条件</strong>。</p> <p>如果<code>shouldUpdate</code>为<em>false</em>且没有捕获到错误就会调用<code>bailoutOnAlreadyFinishedWork</code>方法复用上次的<code>Fiber</code>节点作为返回值。如果<code>shouldUpdate</code>为<em>true</em>，则代表本次<strong>需要更新</strong>并执行组件的<code>render</code>方法完成组件渲染。</p> <h2 id="函数组件性能优化"><a href="#函数组件性能优化" class="header-anchor">#</a> 函数组件性能优化</h2> <p>通常组件层面的性能优化的目的是<strong>避免组件进行不必要的渲染</strong>，达到做到性能优化的目的。</p> <p>而函数组件自身的性能手段就比较单一，只有<code>useState</code>和<code>useReducer</code>返回的<code>dispatch</code>方法内部存在优化特性。</p> <p>函数组件还有另外一种优化方式，使用的场景是父子组件，在父组件用<code>useMemo</code>对子组件进行<strong>缓存</strong>，将子组件使用的参数作为<code>useMemo</code>的<code>deps（依赖项）</code>使用。这种使用方法就是将组件作为一个值使用，通过<code>useMemo</code>缓存起来，避免不必要的执行。且只有当组件的参数改变了，即依赖项的值改变了，<code>useMemo</code>才会重新执行回调函数即重新渲染子组件。</p> <h2 id="类组件性能优化"><a href="#类组件性能优化" class="header-anchor">#</a> 类组件性能优化</h2> <p>相比之下，类组件的性能优化有段就比较多了，比如上文提到的使用<code>shouldComponentUpdate</code>生命周期函数，这属于从<code>组件自身控制渲染</code>。另外还有一种通过组件自身控制组件渲染的方式，就是使用<code>React.PureComponent</code>类型。作用与<code>React.Component</code>是一样的，不过<code>PureComponent</code>有一项额外的特性，那就是对于<em>旧新props</em>和<em>旧新state</em>会进行<strong>浅比较</strong>，如果两组<strong>浅比较</strong>都相等，就不会触发执行类组件的渲染。</p> <p>如代码所示：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">checkShouldComponentUpdate</span><span class="token punctuation">(</span>
  <span class="token parameter">workInProgress<span class="token punctuation">,</span>
  ctor<span class="token punctuation">,</span>
  oldProps<span class="token punctuation">,</span>
  newProps<span class="token punctuation">,</span>
  oldState<span class="token punctuation">,</span>
  newState<span class="token punctuation">,</span>
  nextContext<span class="token punctuation">,</span></span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> instance <span class="token operator">=</span> workInProgress<span class="token punctuation">.</span>stateNode<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> instance<span class="token punctuation">.</span>shouldComponentUpdate <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> shouldUpdate <span class="token operator">=</span> instance<span class="token punctuation">.</span><span class="token function">shouldComponentUpdate</span><span class="token punctuation">(</span>
      newProps<span class="token punctuation">,</span>
      newState<span class="token punctuation">,</span>
      nextContext<span class="token punctuation">,</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> shouldUpdate<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>ctor<span class="token punctuation">.</span>prototype <span class="token operator">&amp;&amp;</span> ctor<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>isPureReactComponent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token operator">!</span><span class="token function">shallowEqual</span><span class="token punctuation">(</span>oldProps<span class="token punctuation">,</span> newProps<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">shallowEqual</span><span class="token punctuation">(</span>oldState<span class="token punctuation">,</span> newState<span class="token punctuation">)</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>使用<code>PureComponent</code>的组件肯定是类组件，也就按照类组件更新时调用同样的方式。在代码中可以看到<code>PureComponent</code>处理优化逻辑的函数和<code>shouldComponentUpdate</code>生命周期函数的调用是同一个函数。且<code>shouldComponentUpdate</code>生命周期函数<strong>优先级更高</strong>，如果没有<code>shouldComponentUpdate</code>才会进行<code>PureComponent</code>的<strong>浅比较</strong>逻辑。最后会返回一个<strong>是否需要更新的布尔值</strong>决定是否调用<code>this.render</code>方法。</p> <h2 id="react-memo"><a href="#react-memo" class="header-anchor">#</a> React.memo</h2> <p>React官网对于<code>React.memo</code>方法的描述：</p> <blockquote><p>React.memo是一个高阶组件。</p></blockquote> <blockquote><p>如果组件在相同 props 的情况下渲染相同的结果，那么你可以通过将其包装在 React.memo 中调用，以此通过记忆组件渲染结果的方式来提高组件的性能表现。</p></blockquote> <blockquote><p>默认情况下其只会对复杂对象做浅层对比,如果想要控制对比过程就传入自定义比较函数作为第二个参数。</p></blockquote> <p>所以<code>React.memo</code>也可以作为函数组件和类组件通用的性能优化方法。那么在源码里面，对于使用<code>React.memo</code>包裹的组件又是如何处理的呢？</p> <p>如代码所示：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">beginWork</span><span class="token punctuation">(</span>
  <span class="token parameter">current<span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  workInProgress<span class="token operator">:</span> Fiber<span class="token punctuation">,</span>
  renderLanes<span class="token operator">:</span> Lanes<span class="token punctuation">,</span></span>
<span class="token punctuation">)</span><span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token punctuation">{</span>
    <span class="token comment">// order code...</span>

    <span class="token keyword">switch</span> <span class="token punctuation">(</span>workInProgress<span class="token punctuation">.</span>tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> MemoComponent<span class="token operator">:</span> <span class="token punctuation">{</span>
            <span class="token keyword">const</span> type <span class="token operator">=</span> workInProgress<span class="token punctuation">.</span>type<span class="token punctuation">;</span>
            <span class="token keyword">const</span> unresolvedProps <span class="token operator">=</span> workInProgress<span class="token punctuation">.</span>pendingProps<span class="token punctuation">;</span>
            <span class="token comment">// Resolve outer props first, then resolve inner props.</span>
            <span class="token keyword">let</span> resolvedProps <span class="token operator">=</span> <span class="token function">resolveDefaultProps</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> unresolvedProps<span class="token punctuation">)</span><span class="token punctuation">;</span>
            resolvedProps <span class="token operator">=</span> <span class="token function">resolveDefaultProps</span><span class="token punctuation">(</span>type<span class="token punctuation">.</span>type<span class="token punctuation">,</span> resolvedProps<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token function">updateMemoComponent</span><span class="token punctuation">(</span>
                current<span class="token punctuation">,</span>
                workInProgress<span class="token punctuation">,</span>
                type<span class="token punctuation">,</span>
                resolvedProps<span class="token punctuation">,</span>
                renderLanes<span class="token punctuation">,</span>
            <span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// order code...</span>

<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">updateMemoComponent</span><span class="token punctuation">(</span>
  <span class="token parameter">current<span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  workInProgress<span class="token operator">:</span> Fiber<span class="token punctuation">,</span>
  Component<span class="token operator">:</span> any<span class="token punctuation">,</span>
  nextProps<span class="token operator">:</span> any<span class="token punctuation">,</span>
  renderLanes<span class="token operator">:</span> Lanes<span class="token punctuation">,</span></span>
<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">null</span> <span class="token operator">|</span> Fiber <span class="token punctuation">{</span>
    <span class="token comment">// order cdoe...</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>hasScheduledUpdateOrContext<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 获取旧props</span>
        <span class="token keyword">const</span> prevProps <span class="token operator">=</span> currentChild<span class="token punctuation">.</span>memoizedProps<span class="token punctuation">;</span>
        <span class="token comment">// 默认为浅比较</span>
        <span class="token keyword">let</span> compare <span class="token operator">=</span> Component<span class="token punctuation">.</span>compare<span class="token punctuation">;</span>
        <span class="token comment">// 比较函数</span>
        compare <span class="token operator">=</span> compare <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">?</span> compare <span class="token operator">:</span> shallowEqual<span class="token punctuation">;</span>
        <span class="token comment">// nextProps为新props</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compare</span><span class="token punctuation">(</span>prevProps<span class="token punctuation">,</span> nextProps<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> current<span class="token punctuation">.</span>ref <span class="token operator">===</span> workInProgress<span class="token punctuation">.</span>ref<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果旧新props相等，并且前后ref属性相等</span>
        <span class="token comment">// 调用bailoutOnAlreadyFinishedWork方法复用上一次的Fiber节点</span>
        <span class="token keyword">return</span> <span class="token function">bailoutOnAlreadyFinishedWork</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> workInProgress<span class="token punctuation">,</span> renderLanes<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// order code...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在<code>beginWork</code>中对于不同的<code>workInProgress.tag</code>会进行不同组件逻辑的处理。</p> <p>像使用了<code>React.memo</code>包裹的组件对应的<code>React Element</code>属性的<code>$$typeof</code>会被赋值为<code>REACR_MEMO_ELEMENT</code>，也就是<code>workInProgres.tag</code>值为<code>MemoComponent</code>的组件就会调用<code>updateMemoComponent</code>方法创建对应的<code>Fiber节点</code>。在<em>if</em>语句中如果该组件没有被调度更新就会进入优化逻辑，判断是否有传入的<code>compare</code>函数。如果有就使用这个函数，如果没有就使用<strong>浅比较</strong>方法。最后<em>旧新props</em>相等并且该组件<em>前后的ref</em>属性没有变化，将复用前一次更新的<code>Fiber节点</code>作为本次<code>beginWork</code>方法的返回值。也就意味本次更新不会重新执行组件的渲染，达到了性能优化的目的。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/react-blog/docs/implement/useState.html" class="prev">
        实现简易useState
      </a></span> <span class="next"><a href="/react-blog/docs/find/differentBetweenSetStateAndUseState.html">
        setState和useState的区别
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/react-blog/assets/js/app.1296abc1.js" defer></script><script src="/react-blog/assets/js/2.2aa2ea89.js" defer></script><script src="/react-blog/assets/js/26.03bcf156.js" defer></script>
  </body>
</html>
