(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{430:function(e,t,s){"use strict";s.r(t);var a=s(16),r=Object(a.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h2",{attrs:{id:"react-effect-list的重构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#react-effect-list的重构"}},[e._v("#")]),e._v(" React Effect List的重构")]),e._v(" "),s("p",[e._v("本文来看看React内部Effects List机制重构的前因后果。")]),e._v(" "),s("h3",{attrs:{id:"什么是副作用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是副作用"}},[e._v("#")]),e._v(" 什么是副作用")]),e._v(" "),s("p",[e._v("React的工作流程可以简单的概括为：")]),e._v(" "),s("ul",[s("li",[e._v("触发更新")]),e._v(" "),s("li",[e._v("render阶段：计算更新会造成的副作用")]),e._v(" "),s("li",[e._v("commit阶段：执行副作用")])]),e._v(" "),s("p",[e._v("其中”副作用“包含很多类型，比如：")]),e._v(" "),s("ul",[s("li",[e._v("Placement：指DOM节点的插入或者移动")]),e._v(" "),s("li",[e._v("Passive：指useEffect需要执行回调函数")]),e._v(" "),s("li",[e._v("Update：指需要更新DOM节点的属性")]),e._v(" "),s("li",[e._v("等...")])]),e._v(" "),s("p",[e._v("那么每个节点需要执行的副作用是如何保存的呢？")]),e._v(" "),s("h3",{attrs:{id:"effects-list"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#effects-list"}},[e._v("#")]),e._v(" Effects List")]),e._v(" "),s("p",[e._v("在重构前，render阶段中带有副作用的节点会连接形成单向链表。这条链表就被称为Effects List。"),s("br"),e._v("\n比如，B、C、E存在副作用，将会连接形成Effects List。"),s("br"),e._v("\n而在commit阶段就不需要再从A节点向下深度遍历整棵树，只需要遍历Effects List就能找到所有存在副作用的节点并执行相应的操作了。")]),e._v(" "),s("h3",{attrs:{id:"subtree-flags"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#subtree-flags"}},[e._v("#")]),e._v(" Subtree Flags")]),e._v(" "),s("p",[e._v("在重构之后，在render阶段，对于执行completeWork方法的节点会调用bubbleProperties方法，进行子节点向父节点冒泡的过程。最终，收集到子节点的flags会保存到父节点的Subtree Flags属性上。"),s("br"),e._v("\n比如，B、C、E包含的副作用如图：\n冒泡过程如下（其中节点的副作用对应的属性就是flags）：")]),e._v(" "),s("ol",[s("li",[e._v("B的flags为Passive，会冒泡到A，所以A.SubtreeFlags就包含Passive。")]),e._v(" "),s("li",[e._v("E的flags为Placement，会冒泡到D，所以D.SubtreeFlags包含Placement")]),e._v(" "),s("li",[e._v("D的flags冒泡到C，所以C.SubtreeFlags包含Placement")]),e._v(" "),s("li",[e._v("C的flags为Update，所以C.SubtreeFlags包含Placement，然后C再冒泡到A")]),e._v(" "),s("li",[e._v("最终A.SubtreeFlags包含Passive、Placement、Update")])]),e._v(" "),s("p",[e._v("当执行完这个过程，A节点的SubtreeFlags就包含这三种副作用。"),s("br"),e._v("\n在commit阶段，在根据SubtreeFlags一层一层查找拥有副作用的节点执行对应的操作。"),s("br"),e._v("\n可见，SubtreeFlags需要重新遍历整棵树，而Effects List只需要遍历单向链表即可。显然后者的执行效率是更高的，那么为什么React还要重构掉呢？")]),e._v(" "),s("h3",{attrs:{id:"suspense"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#suspense"}},[e._v("#")]),e._v(" Suspense")]),e._v(" "),s("p",[e._v("答案是：SubtreeFlags遍历子树的操作虽然比Effects List需要遍历更多的节点，但是React18中一种新特性恰恰需要遍历子树。"),s("br"),e._v("\n这个特性就是Suspense。"),s("br"),e._v("\n在开启并发之前，React保证一次render阶段对应一次commit阶段。开启并发之后，针对Suspense内不显示的子树，即不会渲染内容，也不会执行useEffect的回调。要实现这部分处理的基础，就是改变commit阶段遍历的方式，即遍历子树寻找Suspense组件，如果找到了Suspense组件则不会再向下遍历子树执行子节点的副作用了。")]),e._v(" "),s("h3",{attrs:{id:"总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),s("p",[e._v("针对Suspense的这次改进，为React带来一种新的内部组件类型--Offscreen Component。未来它可能是实现React版keep-alive的基础。")])])}),[],!1,null,null,null);t.default=r.exports}}]);